
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>关于javaScript变量、作用域链以及this指针的详解 - WeiKe</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="weike,"> 
    <meta name="description" content="私のすべてを支配してください,Undefined代码：
123456789101112131415var a = 1;function hehe()&amp;#123;         window.alert(a);         ,"> 
    <meta name="author" content="WeiKe_Joe"> 
    <link rel="alternative" href="atom.xml" title="WeiKe" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">WeiKe</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://cn.weikecc.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">关于javaScript变量、作用域链以及this指针的详解</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">关于javaScript变量、作用域链以及this指针的详解</h1>
        <div class="stuff">
            <span>二月 14, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h1><p>代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hehe</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">window</span>.alert(a);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">window</span>.alert(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hehe();</span><br></pre></td></tr></table></figure>

<p>第一个alert：</p>
<p>图片失效！！！</p>
<p>第二个alert：</p>
<p>图片失效！！！</p>
<p>原理我描述如下：</p>
<p>按照javascript作用域链的原理，当一个变量在当前作用域下找不到该变量的定义，会沿着作用域链往上找直到在全局作用域里查找。</p>
<p>按上面的代码所示，虽然函数内部重新定义了变量的值，但在定义之前使用了该变量；按照作用域链的原理会在全局作用域里找到变量定义，而实际情况却是变量未定义，这到底是怎么回事呢？</p>
<p>下面开始本文的主要内容，我会从基础知识一步步讲起。</p>
<h1 id="Javascript的变量"><a href="#Javascript的变量" class="headerlink" title="Javascript的变量"></a>Javascript的变量</h1><p><strong>变量的两种类型：基本类型和引用类型。基本类型是指：Undefined、Null、Boolean、Number和String，引用类型是指多个基本类型构成的对象。</strong></p>
<p>下面我们来看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;sharpxiajun&quot;</span>;</span><br><span class="line">str.attr01 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//  运行结果：sharpxiajun</span></span><br><span class="line"><span class="built_in">console</span>.log(str.attr01);<span class="comment">// 运行结果：undefined</span></span><br></pre></td></tr></table></figure>

<p>运行之，发现基本类型无法添加属性，当然方法也同样不可以，例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.ftn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;str ftn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">str.ftn();</span><br></pre></td></tr></table></figure>

<p>运行之，结果如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/0b3422f10e2c5004f206823ae8303cf2.jpg" alt="img"></p>
<p>当我们使用引用类型时候，结果就和上面完全不同了，大家请看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj1.name = <span class="string">&quot;obj1 name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name);<span class="comment">// 运行结果：obj1 name</span></span><br></pre></td></tr></table></figure>

<p>Javascript里的基本类型是存放在栈区（内存里的栈内存），存储结构如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/8b343f4c69a4b5a0d1143fd8a13d59b7.jpg" alt="img"></p>
<p>javascript里引用类型的存储需要内存的栈区和堆区（内存里的堆内存）共同完成，如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/fc8e5eb613a9aab3fd93368e640fb106.jpg" alt="img"></p>
<p>场景一：如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qqq;</span><br><span class="line"><span class="built_in">console</span>.log(qqq);<span class="comment">// 运行结果：undefined</span></span><br></pre></td></tr></table></figure>

<p>上面的代码就是命名了变量但未初始化，此时在内存里只有栈区的变量标示符而没有变量值，更没有堆区存储的对象。</p>
<p>场景二：如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qqq;</span><br><span class="line"><span class="built_in">console</span>.log(qqq);<span class="comment">// 运行结果：undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(xxx);</span><br></pre></td></tr></table></figure>

<p><img src="http://static.codeceo.com/images/2014/12/acc415c3ba267ac54790d802b6df7fb5.jpg" alt="img"></p>
<p>提示变量未定义！在任何语言里变量未定义就使用都是违法的，但是我们javascript变量未定义也可以使用，怎么我的例子里却不能使用了？</p>
<p>那么我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xxx = <span class="string">&quot;outer xxx&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(xxx);<span class="comment">// 运行结果：outer xxx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFtn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     sss = <span class="string">&quot;inner sss&quot;</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(sss);<span class="comment">// 运行结果：outer sss</span></span><br><span class="line">&#125;</span><br><span class="line">testFtn();</span><br><span class="line"><span class="built_in">console</span>.log(sss);<span class="comment">//运行结果：outer sss</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.sss);<span class="comment">//运行结果：outer sss</span></span><br></pre></td></tr></table></figure>

<p>我们看看window对象的结构，如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/b332fc8eee74c7dd86b014c1469529a3.jpg" alt="img"></p>
<p>由这两个场景我们可以知道：</p>
<p>**<em>*javascript**变量如果没有被var定义也没有赋值操作才会**报出“xxx is not defined”，后续的代码将不能正常运行；而只有赋值操作的变量，不管在哪个作用域里赋值，都是全局变量即window对象*<em>。</em></em></p>
<p>下面我修改一下代码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var a = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hehe</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(a);</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">hehe();</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/9ffa60f9a450358b2850f2b243d85656.jpg" alt="img"></p>
<p>我再改下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var a = 1;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hehe</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="comment">// var a = 2;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">hehe();</span><br></pre></td></tr></table></figure>

<p>运行之，结果如下所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/12ba5a58fbf2cedd1dd846f6461be825.jpg" alt="img"></p>
<p>对比二者代码，我们发现问题的关键是var a=2所引起的！</p>
<p><strong>javascript变量是松散类型即定义时不需要指定变量类型，当变量值确定后才有类型，但没有使用var的变量必须有赋值。</strong></p>
<p>**javascript代码运行前还有一个*<em>预加载*<em>，构造运行环境例如全局环境、函数运行环境和作用域链。环境和作用域的构造就是指定好变量属于哪个作用域，变量的定义是在预加载时完成而非在运行时。*<em>预加载时会扫描所有代码但不运行，当扫描到被赋值操作的变量没有var定义，那么该变量就会被赋予全局变量即window对象。*</em></em></em></p>
<p><strong>重新分析引子里的代码：在函数的局部作用域内变量a被重新定义了，在预加载时a的作用域也就不再属于全局变量而是函数作用域；赋值操作是在运行期执行的，第一次使用a变量时，a变量在局部作用域内还没被赋值，只有栈区的标示符，结果就undefined了。</strong></p>
<p>*<em>javascript两个特别的类型：undefined和null。变量的值为undefined，说明只有栈区的标示符；如果对变量进行赋值基本类型，那么栈区就有值了；如果*</em>**赋值引用类型******那么堆区会有一个对象，而栈区的值则是堆区对象的地址。变量的值是null，说明这个变量是个空对象，栈区的标示符和值都有值，堆区也有个空对象，这么说来null其实比undefined更耗内存了！</p>
<p>那么我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ooo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ooo);<span class="comment">// 运行结果：null</span></span><br><span class="line"><span class="built_in">console</span>.log(ooo == <span class="literal">undefined</span>);<span class="comment">// 运行结果：tru</span></span><br><span class="line"><span class="built_in">console</span>.log(ooo == <span class="literal">null</span>);<span class="comment">// 运行结果：true</span></span><br><span class="line"> <span class="built_in">console</span>.log(ooo === <span class="literal">undefined</span>);<span class="comment">// 运行结果：false</span></span><br><span class="line"><span class="built_in">console</span>.log(ooo === <span class="literal">null</span>);<span class="comment">// 运行结果：true</span></span><br></pre></td></tr></table></figure>

<p><strong>运行之，null可以和undefined相等；但使用更加精确的三等号“===”，发现还是有点不同，其实javascript里null是undefined的父类，要让一个变量是null必须使用等号“=”进行赋值！</strong></p>
<p><strong>javascript开发规范要求变量定义时马上赋值，好处就是程序很难因为变量未定义报错从而终止程序的运行，而且变量定义最好放在变量作用域的最前端。</strong></p>
<p>下面我们再看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">undefined</span> != str &amp;&amp; <span class="literal">null</span> != str &amp;&amp; <span class="string">&quot;&quot;</span> != str)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">undefined</span> != str &amp;&amp; <span class="string">&quot;&quot;</span> != str)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != str &amp;&amp; <span class="string">&quot;&quot;</span> != str)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!!str)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!!str)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>)&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行之，结果都是打印出false。</p>
<p><strong>使用双等号“==”时，undefined和null是一回事，所以第一个if语句的写法完全多余，而第二种和第三种写法是等价，究其本质前三种写法本质都是一致的；第四种写法更加完美，javascript里如果if语句的条件是undefined和null，if判断是false，所以判断代码是否为未定义和null时最好使用！运算符。</strong></p>
<p>代码四里字符串被赋值空字符串时，if的判断也是false。javascript里有五种基本类型，undefined、null、boolean、Number和string，现在我们发现除了Number都可以使用！来判断if的ture和false，那么基本类型Number呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!!num)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之，结果是false；如果我们把num改为负数或正数，那么运行之的结果就是true了。</p>
<p><strong>所以变量初始化值如果基本类型是string就赋值空字符串，如果是number就赋值0，*<em>**if语句就可以判断变量是否初始化过**</em>*！</strong></p>
<p>但是当变量是对象时候，结果却不一样了，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (!!obj)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>)；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之，代码是true。</p>
<p><strong>所以引用类型变量赋值null，if语句就可以判断变量是否初始化过！</strong></p>
<p>场景三：复制变量的值和函数传递参数</p>
<p>首先看看这个场景的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;sharpxiajun&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1;</span><br><span class="line"><span class="built_in">console</span>.log(s1); 运行结果：sharpxiajun</span><br><span class="line"><span class="built_in">console</span>.log(s2); 运行结果：sharpxiajun</span><br><span class="line">s2 = <span class="string">&quot;xtq&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1); 运行结果：sharpxiajun</span><br><span class="line"><span class="built_in">console</span>.log(s2); 运行结果：xtq</span><br></pre></td></tr></table></figure>

<p>上面是基本类型变量的复制，我们再看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj1.name = <span class="string">&quot;obj1 name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name);<span class="comment">// 运行结果：obj1 name</span></span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">// 运行结果：obj1 name</span></span><br><span class="line">obj1.name = <span class="string">&quot;sharpxiajun&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">// 运行结果：sharpxiajun</span></span><br></pre></td></tr></table></figure>

<p>当复制的是对象，obj1和obj2两个对象被关联起来了，obj1的属性改变时，obj2的属性也改变。</p>
<p>我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFtn</span>(<span class="params">sNm,pObj</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(sNm);<span class="comment">// 运行结果：new Name</span></span><br><span class="line">        <span class="built_in">console</span>.log(pObj.oName);<span class="comment">// 运行结果：new obj</span></span><br><span class="line">        sNm = <span class="string">&quot;change name&quot;</span>;</span><br><span class="line">        pObj.oName = <span class="string">&quot;change obj&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sNm = <span class="string">&quot;new Name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> pObj = &#123;<span class="attr">oName</span>:<span class="string">&quot;new obj&quot;</span>&#125;;</span><br><span class="line">testFtn(sNm,pObj);</span><br><span class="line"><span class="built_in">console</span>.log(sNm);<span class="comment">// 运行结果：new Name</span></span><br><span class="line"><span class="built_in">console</span>.log(pObj.oName);<span class="comment">// 运行结果：change obj</span></span><br></pre></td></tr></table></figure>

<p>这个结果和变量复制的结果是一致的。</p>
<p><strong>函数传参的本质就是外部的变量复制到函数参数的变量里，<strong><strong>是按值传递的</strong></strong>。</strong></p>
<p>如下两张图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/1ff244a138b1d849383345b9f7dd715f.jpg" alt="img"></p>
<p><img src="http://static.codeceo.com/images/2014/12/3404e89f1638356f6417e7a9ee4fadf7.jpg" alt="img"></p>
<p>在javascript里变量的存储有三个位置：</p>
<p>位置一：栈区变量标示符；</p>
<p>位置二：栈区变量值（栈区对象地址）；</p>
<p>位置三：堆区对象。</p>
<p>**javascript的变量复制（函数传参也是）本质是传栈区变量值。基本类型的值在**栈区变量值里，复制时**两个变量是独立的；复制引用类型时，*<em>栈区变量值*<em>是堆区对象的地址，因此其中一个改变，另一个也改变。</em></em></p>
<p>原理讲完了，下面我列举一个拔高的例子，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ftn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;test:ftn1&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">var</span> ftn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;test:ftn2&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftn</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">       f();</span><br><span class="line">       f = ftn2;</span><br><span class="line">&#125;</span><br><span class="line">ftn(ftn1);<span class="comment">// 运行结果：test:ftn1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;====================华丽的分割线======================&quot;</span>);</span><br><span class="line">ftn1();<span class="comment">// 运行结果：test:ftn1</span></span><br></pre></td></tr></table></figure>

<p>这个代码以前是这么分析的：f是函数的参数，属于函数的局部作用域，更改f的值，是没法改变ftn1的值，因为到了外部作用域f就失效了。但是这种解释很难说明我上文里给出的函数传参的实例。其实这个问题应该这么分析：在javascript里函数也是对象，局部作用域里f = ftn2操作是将f在栈区变量地址改为ftn2的地址，对ftn1和ftn2没有影响。</p>
<p>**<em>*记住：javascript变量复制和函数传参是在传递栈区变量值，*<em>当栈区变量值为undefined、null、“”（空字符串）、0、false时，if判断是为false，我们可以通过！运算符计算。</em></em></p>
<p>当我们的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!!obj)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果则是true，其中var obj = {}相当于var obj = new Object()。虽然对象里没什么内容，但是在堆区里对象的内存已经分配，栈区变量值已经是内存地址了，所以if判断是true。</p>
<h2 id="3-作用域链相关的问题"><a href="#3-作用域链相关的问题" class="headerlink" title="3) 作用域链相关的问题"></a>3) 作用域链相关的问题</h2><p><strong>了解作用域链前先了解作用域：</strong></p>
<p><strong>作用域在许多程序设计语言中非常重要。 通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</strong></p>
<p>在java里通过{}来设置作用域，在{}里面的变量会得到保护，这种保护就是不让{}里的变量被外部变量混淆。那么{}的方式适合于javascript吗？</p>
<p>我们看看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;sharpxiajun&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s2 = <span class="string">&quot;xtq&quot;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// 运行结果： windows</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;s1:&quot;</span> + <span class="built_in">this</span>.s1 + <span class="string">&quot;;s2:&quot;</span> + <span class="built_in">this</span>.s2);<span class="comment">//运行结果：s1:sharpxiajun;s2:undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;s1:&quot;</span> + <span class="built_in">this</span>.s1 + <span class="string">&quot;;s2:&quot;</span> + s2);<span class="comment">// 运行结果：s1:sharpxiajun;s2:xtq</span></span><br><span class="line">    &#125;</span><br><span class="line">    ftn();</span><br></pre></td></tr></table></figure>

<p>javascript最大的作用域是window，加载时自动构造。上面代码里的大括号是函数定义，函数作用域内定义的s2变量不能被window对象访问的。可以说s2变量是被{}保护起来了，它的生命周期和这个函数的生命周期有关。</p>
<p>但是在javascript语言里还有非函数的{}，我们再看看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">&quot;aaaa&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">// 运行结果：aaaa</span></span><br></pre></td></tr></table></figure>

<p><strong>我们发现javascript里{}有时是起不到定义作用域的功能。这也说明javascript里的作用域定义是和其他语言例如java不同的。</strong></p>
<p>javascript作用域execution context，翻译成执行上下文或执行环境。我们来想想javascript里哪些情况是执行的：</p>
<p>情况一：页面加载时script标签下的代码会顺序执行，而这些能被执行的代码都是属于window的变量或函数；</p>
<p>情况二：函数的名字后面加上小括号()，例如ftn()，执行的是函数。</p>
<p>如此说来，javascript里的执行环境有两类一类是全局执行环境，即window代表的全局环境；一类是函数代表的函数执行环境，这也就是局部作用域。</p>
<p>执行环境有个对象叫做variable object，翻译为变量对象或上下文变量，存储其执行环境里所有的变量和函数，全局执行环境的上下文变量就是window。</p>
<p>javascript执行环境栈execution context stack：每个要被执行的函数会先把函数的执行环境压入到执行环境栈里，执行完后被弹出，控制权交给全局环境；如果函数后面还有代码，代码接着执行；如果函数里嵌套了函数，那么嵌套函数执行完毕后，执行环境栈的控制权就交由了外部函数，然后依次类推，最后就是全局执行环境了。</p>
<p>函数的执行环境被压入到执行环境栈里后，函数执行的第一步不是函数里的第一行代码而是在上下文变量里构造一个作用域链scope chain，保证执行环境里有权访问的变量和函数是有序的。</p>
<p>我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = <span class="string">&quot;b1&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b2 = <span class="string">&quot;b2&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> b1 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ftn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b3 = <span class="string">&quot;b3&quot;</span>;</span><br><span class="line">            b2 = b1;</span><br><span class="line">            b1 = b3;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;b1:&quot;</span> + b1 + <span class="string">&quot;;b2:&quot;</span> + b2 + <span class="string">&quot;;b3:&quot;</span> + b3);<span class="comment">// 运行结果：b1:b3;b2:bbb;b3:b3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ftn2();</span><br><span class="line">    &#125;</span><br><span class="line">    ftn1();</span><br><span class="line"><span class="built_in">console</span>.log(b1);<span class="comment">// 运行结果：b1</span></span><br></pre></td></tr></table></figure>

<p>ftn2函数可以访问变量b1，b2，这个体现了有权访问；当ftn1作用域里改变了b1的值并且把b1变量重新定义为ftn1的局部变量，那么ftn2访问到的b1就是ftn1的，ftn2访问到b1后就不会在全局作用域里查找b1了，这个体现了有序性。</p>
<p>**总结：**作用域指的是执行环境execution context，通过上下文变量variable object体现。**当函数的执行环境压入到了执行环境栈**execution context stack**时上下文变量会构造一个对象作用域链scope chain保证执行环境里有权访问的变量和函数是有序的。作用域链只能向上访问**变量**，直到window，*<em>不允许*<em>向下访问。</em></em></p>
<h2 id="4-this、new、apply和call详解"><a href="#4-this、new、apply和call详解" class="headerlink" title="4)  this、new、apply和call详解"></a>4)  this、new、apply和call详解</h2><p>*<em>this*</em>**对象****：上下文变量构建作用域链时还会构造一个this对象，*<em>是当前执行环境外部上下文变量的一份拷贝，*<em>不包含作用域链变量。</em></em></p>
<p>例如代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = <span class="string">&quot;b1&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// 运行结果： window</span></span><br><span class="line">        <span class="keyword">var</span> b2 = <span class="string">&quot;b2&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> b1 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">ftn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// 运行结果： window</span></span><br><span class="line">            <span class="keyword">var</span> b3 = <span class="string">&quot;b3&quot;</span>;</span><br><span class="line">            b2 = b1;</span><br><span class="line">            b1 = b3;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;b1:&quot;</span> + b1 + <span class="string">&quot;;b2:&quot;</span> + b2 + <span class="string">&quot;;b3:&quot;</span> + b3);<span class="comment">// 运行结果：b1:b3;b2:bbb;b3:b3</span></span><br><span class="line">        &#125;</span><br><span class="line">        ftn2();</span><br><span class="line">    &#125;</span><br><span class="line">    ftn1();</span><br></pre></td></tr></table></figure>

<p>函数ftn1和ftn2里的this指针都是指向window，这是为什么了？因为通过function xxx(){}形式定义函数，这个函数不管在哪定义都属于window。</p>
<p>但是我们知道很多this指针都不是指向window，例如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;sharpxiajun&quot;</span>,</span><br><span class="line">    <span class="attr">ftn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// 运行结果: Object &#123; name=&quot;sharpxiajun&quot;, ftn=function()&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//运行结果: sharpxiajun</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.ftn();<span class="comment">// ：</span></span><br></pre></td></tr></table></figure>

<p>这里this指针指向了Object，我前文不是说javascript里作用域只有两种：一个是全局的一个是函数，为什么这里Object也是可以制造出作用域？</p>
<p>那我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj1.name = <span class="string">&quot;xtq&quot;</span>;</span><br><span class="line">obj1.ftn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// 运行结果: Object &#123; name=&quot;xtq&quot;, ftn=function()&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//运行结果: xtq</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.ftn();</span><br></pre></td></tr></table></figure>

<p><strong>这两种写法是等价的，第一种叫做字面量定义，而第二种是标准写法。Object对象的本质也是个function，调用对象里的函数时，函数的外部执行环境就是obj1本身，this指针也是指向了obj1。</strong></p>
<p>下面我们看看在java语言里是如何使用this指针的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> sex;</span><br><span class="line">    private int age;</span><br><span class="line">    private <span class="built_in">String</span> job;</span><br><span class="line">    public <span class="function"><span class="title">Person</span>(<span class="params"><span class="built_in">String</span> name, <span class="built_in">String</span> sex, int age, <span class="built_in">String</span> job</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">showPerson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + <span class="built_in">this</span>.sex);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;工作：&quot;</span> + <span class="built_in">this</span>.job);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">printInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.showPerson();</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;马云&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">46</span>, <span class="string">&quot;董事长&quot;</span>);</span><br><span class="line">        person.printInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//姓名：马云</span></span><br><span class="line"><span class="comment">//性别：男</span></span><br><span class="line"><span class="comment">//年龄：46</span></span><br><span class="line"><span class="comment">//工作：董事长</span></span><br></pre></td></tr></table></figure>

<p>上面的代码执行后没有任何问题，下面我修改下这个代码，加一个静态的方法，静态方法里使用this指针调用类里的属性，如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2014/12/410996857f01a2ae265b26f3d033b096.jpg" alt="img"></p>
<p>我们发现IDE会报出语法错误“Cannot use this in a static context”，this指针在java语言里是不能在静态方法里使用的。</p>
<p>在面向对象编程里有两个重要的概念：一个是类，一个是实例化的对象。类是一个抽象的概念，类就像一个模具，而实例化对象就是通过这个模具制造出来的产品。</p>
<p>有上面代码我们可以看到，this指针在java语言里只能在实例化对象里使用，this指针等于这个被实例化好的对象，而this后面加上点操作符后面的东西就是this所拥有的东西，例如：姓名，工作，手，脚等等。</p>
<p>javascript的this指针也只能在实例化对象里使用，但是javascript的this指针却比java难以理解的多，原因得有三：</p>
<p>原因一：javascript是一个函数编程语言，也是面向对象的语言；javascript的函数是高阶函数，可以作为对象传递，还可以作为构造函数，创建实例化对象，结果导致方法执行时候this指针的指向会不断发生变化。</p>
<p>原因二：由上面java的例子我们看到，this指针只有在使用new操作符后才会生效；但是javascript里的this在没有进行new操作也会生效，这时候this往往会指向全局对象window。</p>
<p>原因三：javascript里call和apply操作符可以改变this指针。</p>
<p>我们先看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//aaa</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);<span class="comment">//aaa</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a);<span class="comment">//aaa</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>);<span class="comment">// window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> == <span class="built_in">window</span>);<span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>);<span class="comment">// true</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>script标签里直接使用this指针就指向window，window在页面加载时由javascript引擎完成。程序员无法通过编程语言来控制这个实例化过程，所以开发时就没有构建这个this指针的感觉，常常会忽视它。</p>
<p>还和function的使用有关，我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn01</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;I am ftn01!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ftn02 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I am ftn02!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上面是两种定义函数的方式，第一种称作声明函数，第二种称作函数表达式，这两种方式的区别常常会让我们混淆this指针的使用。</p>
<p>我们再看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(ftn01);<span class="comment">//ftn01()  注意：在firebug下这个打印结果是可以点击，点击后会显示函数的定义</span></span><br><span class="line">    <span class="built_in">console</span>.log(ftn02);<span class="comment">// undefined</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn01</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;I am ftn01!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ftn02 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;I am ftn02!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这又是一段没有按顺序执行的代码，ftn02打印结果是undefined，有栈区变量标识符，没有栈区变量值，堆区没有对象，这是javascript引擎在预处理时扫描变量定义所致。ftn01打印出完整的函数定义，这只能说明一个问题：</p>
<p>**<em>*声明函数会在预处理时把函数定义和赋值操作都完成，且声明函数都是window对象的属性*<em>。</em></em></p>
<p>关于函数表达式的写法还有秘密可以探寻，我们看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn03</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ftn04 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// window</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ftn04();</span><br><span class="line">    &#125;</span><br><span class="line">    ftn03();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>ftn04虽然在ftn03作用域下，但是它里面的this指针指向window。说明<strong>函数表达式在函数内部写时，this指针指向window。</strong></p>
<p><strong>原因是javascript里任何匿名函数都是属于window，在全局作用域构造时完成定义和赋值。匿名函数是没有名字的变量，定义时会返回内存地址；如果有个变量接收了这个地址，那么匿名函数就能使用了；匿名函数是在全局执行环境构造时定义和赋值，所以匿名函数内的this指向window对象。</strong></p>
<p>这下子坏了，this都指向window，那我们到底怎么才能改变它了？</p>
<p>在本文开头我说出了this的秘密，this都是指向实例化对象，前面讲到那么多情况this都指向window，就是因为这些时候只做了一次实例化操作，实例化window对象，所以this都是指向window。我们要把this从window变成别的对象，就得要让function被实例化，那如何让javascript的function实例化呢？</p>
<p>答案就是使用new操作符。我们看看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;sharpxiajun&quot;</span>,</span><br><span class="line">        <span class="attr">job</span>:<span class="string">&quot;Software&quot;</span>,</span><br><span class="line">        <span class="attr">show</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Name:&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;;Job:&quot;</span> + <span class="built_in">this</span>.job);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// Object &#123; name=&quot;sharpxiajun&quot;, job=&quot;Software&quot;, show=function()&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> otherObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    otherObj.name = <span class="string">&quot;xtq&quot;</span>;</span><br><span class="line">    otherObj.job = <span class="string">&quot;good&quot;</span>;</span><br><span class="line">    otherObj.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Name:&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;;Job:&quot;</span> + <span class="built_in">this</span>.job);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// Object &#123; name=&quot;xtq&quot;, job=&quot;good&quot;, show=function()&#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    obj.show();<span class="comment">//Name:sharpxiajun;Job:Software</span></span><br><span class="line">    otherObj.show();<span class="comment">//Name:xtq;Job:good</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这是我上篇讲到的关于this指向Object的实例。Javascript里通过字面量方式定义对象的方式是new Object的简写，二者是等价的，本质也是new操作符。</p>
<p>下面我使用javascript来重写本篇开头用java定义的类，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,sex,age,job</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">        <span class="built_in">this</span>.showPerson = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;姓名:&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;性别:&quot;</span> + <span class="built_in">this</span>.sex);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;年龄:&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;工作:&quot;</span> + <span class="built_in">this</span>.job);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">// Person &#123; name=&quot;马云&quot;, sex=&quot;男&quot;, age=46, 更多...&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;马云&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">46</span>, <span class="string">&quot;董事长&quot;</span>);</span><br><span class="line">    person.showPerson();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>function Person相当于在定义一个类，javascript的function既是函数又是对象；javascript的构造函数可以理解为类和构造函数合二为一，当然javascript语言规范里是没有类的概念。</p>
<p><strong>new操作符会让构造函数产生如下变化：</strong></p>
<p><strong>1. 创建一个新对象；</strong></p>
<p><strong>2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</strong></p>
<p><strong>3. 执行构造函数中的代码（为这个新对象添加属性）；</strong></p>
<p><strong>4. 返回新对象</strong></p>
<p>第四点要着重讲下，记住构造函数被new操作，要让new正常作用最好不要在构造函数里写return，没有return的构造函数都是按上面四点执行，有了return情况就复杂了，这个知识我会在讲prototype时候讲到。</p>
<p><strong>Javascript改变this指针还有call和apply，它们的作用相同，只是参数不同。call和apply的第一个参数一样，apply第二个参数是数组，call从第二个参数开始后面有许多参数。</strong></p>
<p>我们看看下面的码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;sharpxiajun&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ftn</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftn(<span class="string">&quot;101&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&quot;xtq&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ftn.call(obj,<span class="string">&quot;102&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 结果如下所示：</span></span><br><span class="line"><span class="comment">    *101</span></span><br><span class="line"><span class="comment">     T002.html (第 73 行)</span></span><br><span class="line"><span class="comment">     sharpxiajun</span></span><br><span class="line"><span class="comment">     T002.html (第 74 行)</span></span><br><span class="line"><span class="comment">     Window T002.html</span></span><br><span class="line"><span class="comment">     T002.html (第 75 行)</span></span><br><span class="line"><span class="comment">     T002.html (第 73 行)</span></span><br><span class="line"><span class="comment">     xtq</span></span><br><span class="line"><span class="comment">     T002.html (第 74 行)</span></span><br><span class="line"><span class="comment">     Object &#123; name=&quot;xtq&quot;&#125;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其实理清上面情况也是有迹可循的，就以定义对象里的方法有传入函数参数为例：</p>
<p>情形一：传入的参数是函数的别名，那么函数的this就是指向window；</p>
<p>情形二：传入的参数是被new过的构造函数，那么this就是指向实例化的对象本身；</p>
<p>情形三：如果想把被传入的函数对象里this的指针指向外部字面量定义的对象，那么我们就是用apply和call</p>
<p>我们可以通过代码看出我的结论，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;I am window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;sharpxiajun&quot;</span>,</span><br><span class="line">    <span class="attr">job</span>:<span class="string">&quot;Software&quot;</span>,</span><br><span class="line">    <span class="attr">ftn01</span>:<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        obj.show();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ftn02</span>:<span class="function"><span class="keyword">function</span>(<span class="params">ftn</span>)</span>&#123;</span><br><span class="line">        ftn();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ftn03</span>:<span class="function"><span class="keyword">function</span>(<span class="params">ftn</span>)</span>&#123;</span><br><span class="line">        ftn.call(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;姓名:&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">obj.ftn01(p);</span><br><span class="line">obj.ftn02(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">obj.ftn03(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci=''
        data-cs=''
        data-r='suda'
        data-o='xixi-cmd'
        data-a='xixi-cmd'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Undefined"><span class="toc-number">1.</span> <span class="toc-text">Undefined</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Javascript%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">Javascript的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">3) 作用域链相关的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-this%E3%80%81new%E3%80%81apply%E5%92%8Ccall%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">4)  this、new、apply和call详解</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
