
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>F-link - WeiKe</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="weike,"> 
    <meta name="description" content="私のすべてを支配してください,Apache Flink 是一个在无界和有界数据流上进行状态计算的框架和分布式处理引擎.Flink 已经可以在所有常见的集群环境中运行,并以 in-memory 的速度和任意的规模进行计算.
可以类,"> 
    <meta name="author" content="WeiKe_Joe"> 
    <link rel="alternative" href="atom.xml" title="WeiKe" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">WeiKe</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://cn.weikecc.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">F-link</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">F-link</h1>
        <div class="stuff">
            <span>五月 22, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Flink/" rel="tag">Flink</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>


        </div>
        <div class="content markdown">
            <p><strong>Apache Flink</strong> 是一个在无界和有界数据流上进行状态计算的框架和分布式处理引擎.Flink 已经可以在所有常见的集群环境中运行,并以 in-memory 的速度和任意的规模进行计算.</p>
<p>可以类比 <strong>spring batch</strong> 或者<strong>spark</strong>进行学习,基本流程就是<strong>source-&gt;computer/transformation-&gt;sink</strong></p>
<p>本文章的大部分文字都来源于互联网,最底下会附上链接.</p>
<span id="more"></span>

<h3 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h3><h4 id="搭建执行环境"><a href="#搭建执行环境" class="headerlink" title="搭建执行环境"></a>搭建执行环境</h4><p>这边通过 <strong>docker-compose</strong> 构建,当然也可以直接下载编译好的二进制版本了,<a target="_blank" rel="noopener" href="https://flink.apache.org/downloads.html">download</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jobmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">flink</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6123&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JOB_MANAGER_RPC_ADDRESS=jobmanager</span></span><br><span class="line">  <span class="attr">taskmanager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">flink</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6121&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6122&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jobmanager</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">taskmanager</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;jobmanager:jobmanager&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JOB_MANAGER_RPC_ADDRESS=jobmanager</span></span><br></pre></td></tr></table></figure>

<h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>这里根据创建一个<code>WordCount</code>应用</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter() <span class="comment">// this applies only to the Gradle &#x27;Shadow&#x27; plugin</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.github.jengelman.gradle.plugins:shadow:2.0.4&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;application&#x27;</span></span><br><span class="line">    <span class="comment">// shadow plugin to produce fat JARs</span></span><br><span class="line">    id <span class="string">&#x27;com.github.johnrengelman.shadow&#x27;</span> version <span class="string">&#x27;2.0.4&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    flinkShadowJar <span class="comment">// dependencies which go into the shadowJar</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// always exclude these (also from transitive dependencies) since they are provided by Flink</span></span><br><span class="line">    flinkShadowJar.exclude <span class="attr">group:</span> <span class="string">&#x27;org.apache.flink&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;force-shading&#x27;</span></span><br><span class="line">    flinkShadowJar.exclude <span class="attr">group:</span> <span class="string">&#x27;com.google.code.findbugs&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;jsr305&#x27;</span></span><br><span class="line">    flinkShadowJar.exclude <span class="attr">group:</span> <span class="string">&#x27;org.slf4j&#x27;</span></span><br><span class="line">    flinkShadowJar.exclude <span class="attr">group:</span> <span class="string">&#x27;org.apache.logging.log4j&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    javaVersion = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    flinkVersion = <span class="string">&#x27;1.11.2&#x27;</span></span><br><span class="line">    scalaBinaryVersion = <span class="string">&#x27;2.12&#x27;</span></span><br><span class="line">    slf4jVersion = <span class="string">&#x27;1.7.15&#x27;</span></span><br><span class="line">    log4jVersion = <span class="string">&#x27;2.12.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&quot;org.apache.flink:flink-streaming-java_$&#123;scalaBinaryVersion&#125;:$&#123;flinkVersion&#125;&quot;</span></span><br><span class="line">    compile <span class="string">&quot;org.apache.flink:flink-clients_$&#123;scalaBinaryVersion&#125;:$&#123;flinkVersion&#125;&quot;</span></span><br><span class="line">    compile <span class="string">&quot;org.apache.flink:flink-connector-kafka_$&#123;scalaBinaryVersion&#125;:$&#123;fflinkVersion&#125;&quot;</span></span><br><span class="line">    compile <span class="string">&#x27;org.slf4j:slf4j-simple:1.7.21&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make compileOnly dependencies available for tests:</span></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main.compileClasspath += configurations.flinkShadowJar</span><br><span class="line">    main.runtimeClasspath += configurations.flinkShadowJar</span><br><span class="line"></span><br><span class="line">    test.compileClasspath += configurations.flinkShadowJar</span><br><span class="line">    test.runtimeClasspath += configurations.flinkShadowJar</span><br><span class="line"></span><br><span class="line">    javadoc.classpath += configurations.flinkShadowJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run.classpath = sourceSets.main.runtimeClasspath</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">&#x27;Built-By&#x27;</span>: System.getProperty(<span class="string">&#x27;user.name&#x27;</span>),</span><br><span class="line">                <span class="string">&#x27;Build-Jdk&#x27;</span>: System.getProperty(<span class="string">&#x27;java.version&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shadowJar &#123;</span><br><span class="line">    configurations = [project.configurations.flinkShadowJar]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取本地执行环境</span></span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 设置并行数量</span></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取数据流</span></span><br><span class="line">        DataStream&lt;String&gt; stream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 转换算子处理数据流并输出结果</span></span><br><span class="line">        stream.flatMap(<span class="keyword">new</span> Tokenizer()).keyBy(r -&gt; r.f0).sum(<span class="number">1</span>).print();</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        env.execute(<span class="string">&quot;Flink Streaming Java API Skeleton&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tokenizer</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String[] stringList = value.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String s : stringList) &#123;</span><br><span class="line">                <span class="comment">// 使用out.collect方法向下游发送数据</span></span><br><span class="line">                out.collect(<span class="keyword">new</span> Tuple2(s, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是在<strong>IDEA</strong>本地运行的话,记得引入依赖<code>flink-clients</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br></pre></td></tr></table></figure>

<p>如果，已经搭建好了 <strong>Flink WebUI</strong> 运行环境,上传提交编译好的jar包 <strong>JobGraph</strong> 即可,或者通过命令行运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink run -c todo.lib.flink.WordCount WordCount.jar</span><br></pre></td></tr></table></figure>

<h3 id="DataStream-API"><a href="#DataStream-API" class="headerlink" title="DataStream API"></a>DataStream API</h3><h4 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h4><h5 id="内置数据源"><a href="#内置数据源" class="headerlink" title="内置数据源"></a>内置数据源</h5><h6 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h6><p>从数组或者集合，一般本地调试使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] elementInput = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello Flink&quot;</span>, <span class="string">&quot;Second Line&quot;</span>&#125;;</span><br><span class="line">DataStream&lt;String&gt; stream = env.fromElements(elementInput);</span><br></pre></td></tr></table></figure>

<h6 id="File"><a href="#File" class="headerlink" title="File"></a>File</h6><p>可以使用 <code>readTextFile</code> 方法直接读取文本文件, 这种方式可以用来监控一下 <strong>log</strong> 日志文件, 也可以使用 <code>readFile</code> 方法通过指定 <code>InputFormat</code> 来读取特定数据类型的文件, <code>InputFormat</code>可以是内置类,如 <code>CsvInputFormat</code> 或者用户自定义 <code>InputFormat</code> 接口类.</p>
<p>在 <code>readFile()</code> 方法中有一项参数为 <code>WatchType</code>, 共有两种模式 (<code>PROCESS_CONTINUOUSLY </code>/ <code>PROCESS_ONCE</code>). 在 <code>PROCESS_CONTINUOUSLY</code> 模式下, 检测到文件变动就会将文件全部内容加载在 <strong>flink</strong>, 在 <code>PROCESS_ONCE</code> 模式下, 只会将文件变动的那部分加载到 <strong>flink</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加文件源</span></span><br><span class="line"><span class="comment">// 直接读取文本文件</span></span><br><span class="line">DataStream&lt;String&gt; stream = env.readTextFile(logPath);</span><br><span class="line"><span class="comment">// 读取csv</span></span><br><span class="line">CsvInputFormat csvInput = <span class="keyword">new</span> RowCsvInputFormat(</span><br><span class="line">    <span class="keyword">new</span> Path(csvPath),                                        <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="keyword">new</span> TypeInformation[]&#123;Types.STRING, Types.STRING, Types.STRING&#125;,<span class="comment">// 字段类型</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span>,                                             <span class="comment">// 行分隔符</span></span><br><span class="line">    <span class="string">&quot;,&quot;</span>);                                            <span class="comment">// 字段分隔符</span></span><br><span class="line">csvInput.setSkipFirstLineAsHeader(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 指定 CsvInputFormat, 监控csv文件(两种模式), 时间间隔是10ms</span></span><br><span class="line">DataStream&lt;Row&gt; stream = env.readFile(csvInput, csvPath, FileProcessingMode.PROCESS_CONTINUOUSLY, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h6 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加Socket作为数据输入源</span></span><br><span class="line"><span class="comment">// 4个参数 -&gt; (hostname:Ip地址, port:端口, delimiter:分隔符, maxRetry:最大重试次数)</span></span><br><span class="line">DataStream&lt;String&gt; stream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h5 id="外部数据源"><a href="#外部数据源" class="headerlink" title="外部数据源"></a>外部数据源</h5><p>外部数据源是重头戏, 一般来说项目中均是使用外部数据源作为数据的源头.</p>
<h6 id="第三方数据源"><a href="#第三方数据源" class="headerlink" title="第三方数据源"></a>第三方数据源</h6><p>flink 通过实现 <code>SourceFunction</code> 定义了非常丰富的第三方数据连接器.对于第三方数据源, flink的支持分为三种,有<strong>只读型</strong>(Twitter Streaming API / Netty ), <strong>只写型</strong>( Cassandra / Elasticsearch / hadoop FileSystem), 支持<strong>读写</strong>(Kafka / Amazon Kinesis / RabbitMQ)</p>
<ul>
<li>Apache Kafka (Source / Sink)</li>
<li>Apache Cassandra (Sink)</li>
<li>Amazon Kinesis Streams (Source / Sink)</li>
<li>Elasticsearch (Sink)</li>
<li>Hadoop FileSystem (Sink)</li>
<li>RabbitMQ (Source / Sink)</li>
<li>Apache NiFI (Source / Sink)</li>
<li>Twitter Streaming API (Source)</li>
<li>Apache Bahir 中的连接器:</li>
<li>Apache ActiveMQ (Source / Sink)</li>
<li>Apache Flume (Sink)</li>
<li>Redis (Sink)</li>
<li>Akka (Sink)</li>
<li>Netty (Source)</li>
</ul>
<p><strong>以Kafka 为例 做演示</strong></p>
<p>我这边是远程服务器上<strong>docker-compose</strong>启动<strong>kafka</strong>,主要注意下面的<strong>EN_IP</strong>表示外网的IP地址</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个 kafka节点 就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic</span></span><br><span class="line"><span class="attr">KAFKA_BROKER_ID:</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 配置zookeeper管理kafka的路径</span></span><br><span class="line"><span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span> </span><br><span class="line"><span class="comment"># 把kafka的地址端口注册给zookeeper，若远程访问要改成外网IP,千万注意是外网IP</span></span><br><span class="line"><span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://$&#123;EN_IP&#125;:9092</span> </span><br><span class="line"><span class="comment"># 配置kafka的监听端口</span></span><br><span class="line"><span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://0.0.0.0:9092</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;EN_IP:9092&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">DataStream&lt;String&gt; dataStream = env</span><br><span class="line">    .addSource(<span class="keyword">new</span> FlinkKafkaConsumer&lt;&gt;(<span class="string">&quot;topic&quot;</span>, <span class="keyword">new</span> SimpleStringSchema(), properties));</span><br><span class="line">dataStream.print();</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it kafka_container_id bash</span><br><span class="line">cd /opt/kafka/bin</span><br><span class="line">// 生产数据</span><br><span class="line">./kafka-console-producer.sh --broker-list EN_IP:9092 --topic flink-test</span><br><span class="line">// 消费数据</span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server EN_IP:9092 --topic flink-test --from-beginning</span><br></pre></td></tr></table></figure>

<h6 id="自定义数据源"><a href="#自定义数据源" class="headerlink" title="自定义数据源"></a>自定义数据源</h6><p>用户也可以自己定义连接器, 通过实现 <code>SourceFunction</code> 定义单个线程的接入的数据连接器, 也可以通过实现<code>ParallelSourceFunction</code> 接口或者继承 <code>RichParallelSourceFunction</code> 类定义并发数据源接入器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceFromMySQL</span> <span class="keyword">extends</span> <span class="title">RichSourceFunction</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    PreparedStatement ps;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;User&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ResultSet resultSet = ps.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User(</span><br><span class="line">                resultSet.getInt(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">                resultSet.getString(<span class="string">&quot;name&quot;</span>).trim());</span><br><span class="line">            ctx.collect(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br></pre></td></tr></table></figure>



<h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><h5 id="基本转换算子"><a href="#基本转换算子" class="headerlink" title="基本转换算子"></a>基本转换算子</h5><p>基本转换算子会针对流中的每一个单独的事件做处理,也就是说每一个输入数据会产生一个输出数据.单值转换,数据的分割,数据的过滤,都是基本转换操作的典型例子.这个有个概念就行,可以跳过.</p>
<h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; filteredReadings = readings.filter(r -&gt; r.temperature &gt;= <span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; sensorIds = filteredReadings.map(r -&gt; r.id);</span><br></pre></td></tr></table></figure>

<h6 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; splitIds = sensorIds</span><br><span class="line">    .flatMap((FlatMapFunction&lt;String, String&gt;)</span><br><span class="line">             (id, out) -&gt; &#123; <span class="keyword">for</span> (String s: id.split(<span class="string">&quot;_&quot;</span>)) &#123; out.collect(s);&#125;&#125;)</span><br><span class="line">    <span class="comment">// provide result type because Java cannot infer return type of lambda function</span></span><br><span class="line">    <span class="comment">// 提供结果的类型，因为Java无法推断匿名函数的返回值类型</span></span><br><span class="line">    .returns(Types.STRING);</span><br></pre></td></tr></table></figure>

<h6 id="richFunction"><a href="#richFunction" class="headerlink" title="richFunction"></a>richFunction</h6><p>在函数处理数据之前,需要做一些初始化的工作;或者需要在处理数据时可以获得函数执行上下文的一些信息;以及在处理完数据时做一些清理工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMap</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Integer</span>, <span class="title">Tuple2</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> subTaskIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subTaskIndex = getRuntimeContext.getIndexOfThisSubtask;</span><br><span class="line">    <span class="comment">// 做一些初始化工作</span></span><br><span class="line">    <span class="comment">// 例如建立一个和HDFS的连接</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Integer in, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in % <span class="number">2</span> == subTaskIndex) &#123;</span><br><span class="line">      out.collect((subTaskIndex, in));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理工作，断开和HDFS的连接。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="键控流转换算子"><a href="#键控流转换算子" class="headerlink" title="键控流转换算子"></a>键控流转换算子</h5><p>很多流处理程序的一个基本要求就是要能对数据进行分组,分组后的数据共享某一个相同的属性.<strong>DataStream API</strong>提供了一个叫做<code>KeyedStream</code>的抽象,此抽象会从逻辑上对DataStream进行分区,分区后的数据拥有同样的<code>Key</code>值,分区后的流互不相关.</p>
<h6 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy"></a>keyBy</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KeyedStream&lt;SensorReading, String&gt; keyed = readings.keyBy(r -&gt; r.id);</span><br></pre></td></tr></table></figure>

<h6 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h6><p>通过将最后一个文件夹流与当前记录组合来推出 KeyedStream.它会发回数据流.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeyedStream.fold(<span class="string">&quot;1&quot;</span>, <span class="keyword">new</span> FoldFunction&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fold</span><span class="params">(String accumulator, Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h6><p>滚动聚合算子由<code>KeyedStream</code>调用,并生成一个聚合以后的DataStream.</p>
<p>滚动聚合算子只能用在滚动窗口,不能用在滑动窗口.</p>
<p>滚动聚合操作会对每一个key都保存一个状态。因为状态从来不会被清空，所以我们在使用滚动聚合算子时只能使用在含有有限个key的流上面。</p>
<p>常见的滚动聚合算子: sum,min,max,minBy,maxBy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple3&lt;Integer, Integer, Integer&gt;&gt; resultStream = inputStream</span><br><span class="line">    .keyBy(<span class="number">0</span>) <span class="comment">// key on first field of the tuple</span></span><br><span class="line">    .sum(<span class="number">1</span>);   <span class="comment">// sum the second field of the tuple in place</span></span><br></pre></td></tr></table></figure>

<h6 id="window"><a href="#window" class="headerlink" title="window"></a>window</h6><p>允许按时间或其他条件对现有 KeyedStream 进行分组.以下是以 10 秒的时间窗口聚合:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputStream.keyBy(<span class="number">0</span>).window(Time.seconds(<span class="number">10</span>));</span><br><span class="line">inputStream.keyBy(<span class="number">0</span>).windowAll(Time.seconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h6 id="window-join"><a href="#window-join" class="headerlink" title="window join"></a>window join</h6><p>我们可以通过一些 key 将同一个 window 的两个数据流 join 起来.</p>
<p>以下示例是在 5 秒的窗口中连接两个流,其中第一个流的第一个属性的连接条件等于另一个流的第二个属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inputStream.join(inputStream1)</span><br><span class="line">           .where(<span class="number">0</span>).equalTo(<span class="number">1</span>)</span><br><span class="line">           .window(Time.seconds(<span class="number">5</span>))     </span><br><span class="line">           .apply (<span class="keyword">new</span> JoinFunction () &#123;...&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="split"><a href="#split" class="headerlink" title="split"></a>split</h6><p>此功能根据条件将流拆分为两个或多个流.当您获得混合流并且您可能希望单独处理每个数据流时,可以使用此方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SplitStream&lt;Integer&gt; split = inputStream.split(<span class="keyword">new</span> OutputSelector&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">select</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">        <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            output.add(<span class="string">&quot;even&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            output.add(<span class="string">&quot;odd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="select"><a href="#select" class="headerlink" title="select"></a>select</h6><p>此功能允许您从拆分流中选择特定流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SplitStream&lt;Integer&gt; split;</span><br><span class="line">DataStream&lt;Integer&gt; even = split.select(<span class="string">&quot;even&quot;</span>); </span><br><span class="line">DataStream&lt;Integer&gt; odd = split.select(<span class="string">&quot;odd&quot;</span>); </span><br><span class="line">DataStream&lt;Integer&gt; all = split.select(<span class="string">&quot;even&quot;</span>,<span class="string">&quot;odd&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="project"><a href="#project" class="headerlink" title="project"></a>project</h6><p>Project 函数允许您从事件流中选择属性子集,并仅将所选元素发送到下一个处理流.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple4&lt;Integer, Double, String, String&gt;&gt; in = <span class="comment">// [...] </span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; out = in.project(<span class="number">3</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h6><p>reduce函数可以通过实现接口ReduceFunction来创建一个类.ReduceFunction接口定义了<code>reduce()</code>方法,此方法接收两个输入事件,输入一个相同类型的事件.</p>
<p>reduce作为滚动聚合的泛化实现,同样也要针对每一个key保存状态.因为状态从来不会清空,所以我们需要将reduce算子应用在一个有限key的流上.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; maxTempPerSensor = keyed</span><br><span class="line">    .reduce((r1, r2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (r1.temperature &gt; r2.temperature) &#123;</span><br><span class="line">            <span class="keyword">return</span> r1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="多流转换算子"><a href="#多流转换算子" class="headerlink" title="多流转换算子"></a>多流转换算子</h5><p>许多应用需要摄入多个流并将流合并处理,还可能需要将一条流分割成多条流然后针对每一条流应用不同的业务逻辑.</p>
<h6 id="union"><a href="#union" class="headerlink" title="union"></a>union</h6><p>合流的方式为FIFO方式,合并流类型要一致.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; parisStream = ...</span><br><span class="line">DataStream&lt;SensorReading&gt; tokyoStream = ...</span><br><span class="line">DataStream&lt;SensorReading&gt; rioStream = ...</span><br><span class="line">DataStream&lt;SensorReading&gt; allCities = parisStream</span><br><span class="line">  .union(tokyoStream, rioStream)</span><br></pre></td></tr></table></figure>

<h6 id="connect-comap-coflatmap"><a href="#connect-comap-coflatmap" class="headerlink" title="connect,comap,coflatmap"></a>connect,comap,coflatmap</h6><p>两个流的数据类型可以不同,会对两个流中的数据应用不同的处理方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;Integer, Long&gt;&gt; one = ...</span><br><span class="line">DataStream&lt;Tuple2&lt;Integer, String&gt;&gt; two = ...</span><br><span class="line"><span class="comment">// keyBy two connected streams</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Int, Long&gt;, Tuple2&lt;Integer, String&gt;&gt; keyedConnect1 = one</span><br><span class="line">  .connect(two)</span><br><span class="line">  .keyBy(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// key both input streams on first attribute</span></span><br><span class="line"><span class="comment">// alternative: connect two keyed streams</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;Integer, Long&gt;, Tuple2&lt;Integer, String&gt;&gt; keyedConnect2 = one</span><br><span class="line">  .keyBy(<span class="number">0</span>)</span><br><span class="line">  .connect(two.keyBy(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h5 id="分布式转换算子"><a href="#分布式转换算子" class="headerlink" title="分布式转换算子"></a>分布式转换算子</h5><p>定义了事件如何分配到不同的任务中去</p>
<p>当我们使用DataStream API来编写程序时,系统将自动的选择数据分区策略,然后根据操作符的语义和设置的并行度将数据路由到正确的地方去.有些时候,我们需要在应用程序的层面控制分区策略,或者自定义分区策略</p>
<h6 id="random"><a href="#random" class="headerlink" title="random"></a>random</h6><p>随机数据交换由<code>DataStream.shuffle()</code>方法实现。shuffle方法将数据随机的分配到下游算子的并行任务中去</p>
<h6 id="round-robin"><a href="#round-robin" class="headerlink" title="round-robin"></a>round-robin</h6><p><code>rebalance()</code>方法使用Round-Robin负载均衡算法将输入流平均分配到随后的并行运行的任务中去</p>
<h6 id="rescale"><a href="#rescale" class="headerlink" title="rescale"></a>rescale</h6><p><code>rescale()</code>方法使用的也是round-robin算法,但只会将数据发送到接下来的并行运行的任务中的一部分任务中.本质上,当发送者任务数量和接收者任务数量不一样时,rescale分区策略提供了一种轻量级的负载均衡策略.如果接收者任务的数量是发送者任务的数量的倍数时,rescale操作将会效率更高.</p>
<p><code>rebalance()</code>和<code>rescale()</code>的根本区别在于任务之间连接的机制不同.<code>rebalance()</code>将会针对所有发送者任务和所有接收者任务之间建立通信通道,而<code>rescale()</code>仅仅针对每一个任务和下游算子的一部分子并行任务之间建立通信通道</p>
<h6 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h6><p><code>broadcast()</code>方法将输入流的所有数据复制并发送到下游算子的所有并行任务中去.</p>
<h6 id="global"><a href="#global" class="headerlink" title="global"></a>global</h6><p><code>global()</code>方法将所有的输入流数据都发送到下游算子的第一个并行任务中去.这个操作需要很谨慎,因为将所有数据发送到同一个task,将会对应用程序造成很大的压力.</p>
<h6 id="custom"><a href="#custom" class="headerlink" title="custom"></a>custom</h6><p>当Flink提供的分区策略都不适用时,我们可以使用<code>partitionCustom()</code>方法来自定义分区策略.这个方法接收一个<code>Partitioner</code>对象,这个对象需要实现分区逻辑以及定义针对流的哪一个字段或者key来进行分区.</p>
<h4 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h4><p>Flink没有类似于spark中foreach方法,让用户进行迭代的操作.所有对外的输出操作都要利用Sink完成.最后通过类似如下方式完成整个任务最终输出操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.addSink(<span class="keyword">new</span> MySink(xxxx));</span><br></pre></td></tr></table></figure>

<p>官方提供了一部分的框架的sink.除此以外,需要用户自定义实现sink.</p>
<h5 id="第三方sink"><a href="#第三方sink" class="headerlink" title="第三方sink"></a>第三方sink</h5><h6 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; union = high</span><br><span class="line">  .union(low)</span><br><span class="line">  .map(r -&gt; r.temperature.toString);</span><br><span class="line"></span><br><span class="line">union.addSink(</span><br><span class="line">  <span class="keyword">new</span> FlinkKafkaProducer011&lt;String&gt;(</span><br><span class="line">    <span class="string">&quot;localhost:9092&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> SimpleStringSchema()</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bahir<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSink_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        DataStream&lt;User&gt; stream = env.addSource(<span class="keyword">new</span> UserSource());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FlinkJedisPoolConfig conf = <span class="keyword">new</span> FlinkJedisPoolConfig.Builder().setHost(<span class="string">&quot;localhost&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        stream.addSink(<span class="keyword">new</span> RedisSink&lt;SensorReading&gt;(conf, <span class="keyword">new</span> MyRedisSink()));</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisSink</span> <span class="keyword">implements</span> <span class="title">RedisMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKeyFromData</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> user.getId().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getValueFromData</span><span class="params">(User User)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> user.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RedisCommandDescription <span class="title">getCommandDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedisCommandDescription(RedisCommand.HSET, <span class="string">&quot;flink-test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis_container_id redis-cli</span><br><span class="line">auth 123456</span><br><span class="line">keys keys flink-test</span><br><span class="line">hvals flink-test</span><br></pre></td></tr></table></figure>

<h6 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch6_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选依赖 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsSink_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;User&gt; stream = env.addSource(<span class="keyword">new</span> UserSource());</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        httpHosts.add(<span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">        ElasticsearchSink.Builder&lt;User&gt; sensorReadingBuilder = <span class="keyword">new</span> ElasticsearchSink.Builder&lt;&gt;(</span><br><span class="line">                httpHosts,</span><br><span class="line">                (ElasticsearchSinkFunction&lt;User&gt;) (user, runtimeContext, requestIndexer) -&gt; &#123;</span><br><span class="line">                    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;data&quot;</span>, user.toString());</span><br><span class="line">                    IndexRequest indexRequest = Requests</span><br><span class="line">                            .indexRequest()</span><br><span class="line">                            .index(<span class="string">&quot;flink-test&quot;</span>) <span class="comment">// 索引是flink-test，相当于数据库</span></span><br><span class="line">                            .type(<span class="string">&quot;user&quot;</span>) <span class="comment">// es6需要加这一句</span></span><br><span class="line">                            .source(map);</span><br><span class="line"></span><br><span class="line">                    requestIndexer.add(indexRequest);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        sensorReadingBuilder.setBulkFlushMaxActions(<span class="number">1</span>);</span><br><span class="line">        stream.addSink(sensorReadingBuilder.build());</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义sink"><a href="#自定义sink" class="headerlink" title="自定义sink"></a>自定义sink</h5><p>继承 RichSinkFunction 抽象类,重写 invoke 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJDBCSink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement insertStmt;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement updateStmt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(User value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        updateStmt.setString(<span class="number">1</span>, value.getName());</span><br><span class="line">        updateStmt.setInt(<span class="number">2</span>, value.getId());</span><br><span class="line">        updateStmt.execute();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updateStmt.getUpdateCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            insertStmt.setInt(<span class="number">1</span>, value.getId());</span><br><span class="line">            insertStmt.setString(<span class="number">2</span>, value.getName());</span><br><span class="line">            insertStmt.execute();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>



<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><h5 id="时间-time"><a href="#时间-time" class="headerlink" title="时间 time"></a>时间 time</h5><p>事件时间 <strong>Event Time</strong>,即事件实际发生的时间,可以处理乱序事件,一般都用这个;<br>摄入时间 <strong>Ingestion Time</strong>,事件进入流处理框架的时间;<br>处理时间 <strong>Processing Time</strong>,事件被处理的时间,执行操作算子的本地时间,与机器无关.统计某些延时非常高的日志.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">//设置时间属性为 EventTime</span></span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">DataStream&lt;MyEvent&gt; stream = env.addSource(<span class="keyword">new</span> FlinkKafkaConsumer09&lt;MyEvent&gt;(topic, schema, props));</span><br><span class="line">stream</span><br><span class="line">    .keyBy( (event) -&gt; event.getUser() )</span><br><span class="line">    .timeWindow(Time.hours(<span class="number">1</span>))</span><br><span class="line">    .reduce( (a, b) -&gt; a.add(b) )</span><br><span class="line">    .addSink(...);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法中的 while 循环部分会从 eventTimeTimersQueue 中依次取出触发时间小于参数 time 的所有定时器，调用 triggerTarget.onEventTime() 方法进行触发。这就是 EventTime 从注册到触发的流程。</span></span><br><span class="line">InternalTimeServiceImpl.advanceWatermark。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advanceWatermark</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   currentWatermark = time;</span><br><span class="line">   InternalTimer&lt;K, N&gt; timer;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> ((timer = eventTimeTimersQueue.peek()) != <span class="keyword">null</span> &amp;&amp; timer.getTimestamp() &lt;= time) &#123;</span><br><span class="line">      eventTimeTimersQueue.poll();</span><br><span class="line">      keyContext.setCurrentKey(timer.getKey());</span><br><span class="line">      triggerTarget.onEventTime(timer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="水位线-watermark"><a href="#水位线-watermark" class="headerlink" title="水位线 watermark"></a>水位线 watermark</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p><strong>水印的出现是为了解决实时计算中的数据乱序问题，它的本质是 DataStream 中一个带有时间戳的元素</strong>。</p>
<p>如果 Flink 系统中出现了一个 WaterMark T,那么就意味着 EventTime &lt; T 的数据都已经到达,窗口的结束时间和 T 相同的那个窗口被<strong>触发</strong>进行计算了.</p>
<p>也就是说:水印是 Flink 判断迟到数据的标准,同时也是窗口触发的标记.</p>
<p>在程序并行度大于 1 的情况下,会有多个流产生水印和窗口,这时候 Flink 会选取时间戳最小的水印.</p>
<h6 id="使用水印"><a href="#使用水印" class="headerlink" title="使用水印"></a>使用水印</h6><p><strong>a. 在 Source Function 中 直接指定 Timestamps 和 Watermark</strong></p>
<p> 用户需要复写 SourceFunction 接口中 run( ) 方法实现数据逻辑, 同时调用 SourceContext 的 collectWithTimestamp( ) 方法生成 event time 时间戳, 调用 emitWatermark( ) 方法生成 watermark.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; text = env.addSource(<span class="keyword">new</span> SourceFunction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;String&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String s : elementInput) &#123;</span><br><span class="line">                    <span class="comment">// 切割每一条数据</span></span><br><span class="line">                    String[] inp = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    Long timestamp = <span class="keyword">new</span> Long(inp[<span class="number">1</span>]);</span><br><span class="line">                    <span class="comment">// 生成 event time 时间戳</span></span><br><span class="line">                    ctx.collectWithTimestamp(s, timestamp);</span><br><span class="line">                    <span class="comment">// 调用 emitWatermark() 方法生成 watermark, 最大延迟设定为 2</span></span><br><span class="line">                    ctx.emitWatermark(<span class="keyword">new</span> Watermark(timestamp - <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设定默认 watermark</span></span><br><span class="line">                ctx.emitWatermark(<span class="keyword">new</span> Watermark(Long.MAX_VALUE));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>b. 通过 Flink 自带的 Timestamp Assigner 指定 Timestamp 和 生成 watermark</strong></p>
<p><strong>b.1 使用 Ascending Timestamp Assigner 指定 Timestamps 和 Watermark</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; dataStream = env.fromCollection(collectionInput);</span><br><span class="line">       dataStream.assignTimestampsAndWatermarks(</span><br><span class="line">               (WatermarkStrategy&lt;Tuple2&lt;String, Long&gt;&gt;) context -&gt; <span class="keyword">new</span> WatermarkGenerator&lt;Tuple2&lt;String,Long&gt;&gt;()&#123;</span><br><span class="line">                   <span class="keyword">private</span> <span class="keyword">long</span> maxTimestamp;</span><br><span class="line">                   <span class="keyword">private</span> <span class="keyword">long</span> delay = <span class="number">3000</span>;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                           Tuple2&lt;String,Long&gt; event,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">long</span> eventTimestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                           WatermarkOutput output)</span></span>&#123;</span><br><span class="line">                       maxTimestamp = Math.max(maxTimestamp, event.f1);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span></span>&#123;</span><br><span class="line">                       output.emitWatermark(<span class="keyword">new</span> Watermark(maxTimestamp - delay));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>b.2 内置水印生成策略</strong></p>
<p><strong>b.2.1 固定延迟生成水印</strong></p>
<p>通过静态方法<code>forBoundedOutOfOrderness</code>提供,入参接收一个Duration类型的时间间隔，也就是我们可以接受的最大的延迟时间.使用这种延迟策略的时候需要我们对数据的延迟时间有一个大概的预估判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forBoundedOutOfOrderness(Duration maxOutOfOrderness)</span><br></pre></td></tr></table></figure>

<p>我们实现一个延迟3秒的固定延迟水印，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStream dataStream = ...... ;</span><br><span class="line">dataStream.assignTimestampsAndWatermarks(WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p>他的底层使用的WatermarkGenerator接口的一个实现类BoundedOutOfOrdernessWatermarks。我们看下源码中的这两个方法，是不是和我们上面自己写的很像.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(T event, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line"> maxTimestamp = Math.max(maxTimestamp, eventTimestamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line"> output.emitWatermark(<span class="keyword">new</span> Watermark(maxTimestamp - outOfOrdernessMillis - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b.2.2 单调递增生成水印</strong></p>
<p>通过静态方法<code>forMonotonousTimestamps</code>来提供.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forMonotonousTimestamps()</span><br></pre></td></tr></table></figure>

<p>这个也就是相当于上述的延迟策略去掉了延迟时间，以event中的时间戳充当了水印。</p>
<p>在程序中可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataStream dataStream = ...... ;</span><br><span class="line">dataStream.assignTimestampsAndWatermarks(WatermarkStrategy.forMonotonousTimestamps());</span><br></pre></td></tr></table></figure>

<p>它的底层实现是AscendingTimestampsWatermarks，其实它就是BoundedOutOfOrdernessWatermarks类的一个子类，没有了延迟时间，我们来看看具体源码的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AscendingTimestampsWatermarks</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BoundedOutOfOrdernessWatermarks</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a new watermark generator with for ascending timestamps.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AscendingTimestampsWatermarks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(Duration.ofMillis(<span class="number">0</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="event时间的获取"><a href="#event时间的获取" class="headerlink" title="event时间的获取"></a>event时间的获取</h6><p>上述我们讲了flink自带的两种水印生成策略，但是对于我们使用eventtime语义的时候，我们想从我们的自己的数据中抽取eventtime，这个就需要TimestampAssigner了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimestampAssigner</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ............</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(T element, <span class="keyword">long</span> recordTimestamp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候我们主要就是从我们自己的元素element中提取我们想要的eventtime。</p>
<p>使用flink自带的水印策略和eventtime抽取类，可以这样用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataStream dataStream = ...... ;</span><br><span class="line">dataStream.assignTimestampsAndWatermarks(</span><br><span class="line">    WatermarkStrategy</span><br><span class="line">      .&lt;Tuple2&lt;String,Long&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">      .withTimestampAssigner((event, timestamp)-&gt;event.f1));</span><br></pre></td></tr></table></figure>

<h6 id="处理空闲数据源"><a href="#处理空闲数据源" class="headerlink" title="处理空闲数据源"></a>处理空闲数据源</h6><p>在某些情况下，由于数据产生的比较少，导致一段时间内没有数据产生，进而就没有水印的生成，导致下游依赖水印的一些操作就会出现问题，比如某一个算子的上游有多个算子，这种情况下，水印是取其上游两个算子的较小值，如果上游某一个算子因为缺少数据迟迟没有生成水印，就会出现eventtime倾斜问题，导致下游没法触发计算。</p>
<p>所以filnk通过WatermarkStrategy.withIdleness()方法允许用户在配置的时间内（即超时时间内）没有记录到达时将一个流标记为空闲。这样就意味着下游的数据不需要等待水印的到来。</p>
<p>当下次有水印生成并发射到下游的时候，这个数据流重新变成活跃状态。</p>
<p>通过下面的代码来实现对于空闲数据流的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy</span><br><span class="line">        .&lt;Tuple2&lt;Long, String&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">        .withIdleness(Duration.ofMinutes(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h5 id="窗口简介-window"><a href="#窗口简介-window" class="headerlink" title="窗口简介 window"></a>窗口简介 window</h5><p>窗口是流式计算中非常重要的一个概念, 很多常见的功能都是通过各种窗口实现的, 比如每5分钟统计一下刚去1小时的热度. Flink DataStream API 将窗口独立成 Operator. 每个窗口算子包含了以下几个部分:</p>
<p><strong>Windows Assigner</strong></p>
<p>指定窗口的类型, 定义如何将数据流分配到一个或者多个窗口</p>
<p><strong>Windows Trigger</strong></p>
<p>指定窗口触发的时机, 定义窗口满足什么样的条件触发计算</p>
<p><strong>Evictor</strong></p>
<p>用户数据剔除</p>
<p><strong>Lateness</strong></p>
<p>标记是否处理迟到的数据, 当迟到数据到达窗口中是否触发计算</p>
<p><strong>Output Tag</strong></p>
<p>标记输出标签, 然后再通过 getSideOutput 将窗口中的数据根据标签输出</p>
<p><strong>Windows Function</strong></p>
<p>定义窗口上的数据处理的逻辑, 例如对数据进行sum</p>
<h5 id="Window-Assigner"><a href="#Window-Assigner" class="headerlink" title="Window Assigner"></a>Window Assigner</h5><p>首先最需要了解的就是 windows Assigner了, 我们想要一个什么样的窗口划分, 主要就是通过他来实现的.</p>
<p>根据 flink 上游的数据集是否为 KeyedStream 类型 来做分别的处理. 如果使用了keyBy( ) 则对应使用window( ) 来处理, 否则可以使用 windowAll( )来使用</p>
<p>Flink 可以支持两种类型的窗口, 分别是基于时间的窗口和基于数量的窗口.基于时间的意思就是按照时间去划分窗口,同理,基于数量的也是根据窗口中的数量来做切分的. 对应的分别就是 timeWindow() 和 countWindow() 来使用, 下面的示例主要使用 timeWindow() 来演示.</p>
<p>对于不同的 Window Assigner, 还可以把窗口划分为4大类, 分别是 滚动窗口(Tumbling Windows) / 滑动窗口(Sliding Window) / 会话窗口(Session Window) 和 全局窗口(Global Window).</p>
<h6 id="滚动窗口-Tumbling-Windows"><a href="#滚动窗口-Tumbling-Windows" class="headerlink" title="滚动窗口 Tumbling Windows"></a>滚动窗口 Tumbling Windows</h6><p>DataStream API 提供基于 EventTime 和 ProcessingTime 的两种类型的 Tumbling window.对应的 Assigner 分别是 TumblingEventTimeWindow 和 ProcessingEventTimeWindow . 举例如下,完整代码见Github.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用ProcessTime的滚动时间窗口, 长度为10s</span><br><span class="line">stream.keyBy(x -&gt; x.f1)</span><br><span class="line">    .window(TumblingProcessingTimeWindows.of(Time.seconds(10))).process(...)</span><br><span class="line">// 使用ProcessTime的滚动时间窗口, 长度为10s</span><br><span class="line">stream.keyBy(x -&gt;x.f1).window(TumblingEventTimeWindows.of(Time.seconds(10))).process(...)</span><br></pre></td></tr></table></figure>

<p>使用 window(TumblingProcessingTimeWindows.of(Time.seconds(10))) 的方法有点啰嗦, Flink 还提供了timeWindow( ) 的 API 来简化这一行代码.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 直接使用 timeWindow API 便可实现滚动窗口的操作, 参数依旧是窗口的长度</span><br><span class="line">// 窗口类型的时间由 time characteristic 确定, 如果指定为 event time,那么窗口也会自动用这个时间</span><br><span class="line">input.keyBy(x -&gt; x.f1).timeWindow(Time.seconds(10));</span><br></pre></td></tr></table></figure>

<h6 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口 Sliding Window"></a>滑动窗口 Sliding Window</h6><p>滑动窗口顾名思义就是一个在不断往后滑动的窗口, 比如说 每5分钟 统计一个 最近一小时的时间, 那么就需要用滑动窗口来做处理. 滑动窗口主要是依靠 window size 和 slide time 来确定. 与滚动窗口类似的, flink 也提供了对应不同时间的 Assigner API(SlidingEventTimeWindow / SlidingEventTimeWindow), 语法基本类似, 只是由原本的一个参数(窗口长度) 变为了两个参数(窗口长度和滑动时间), 同样的, 为了简化代码, 依然可以使用timeWindow() 来简化.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 两个参数分别是 窗口长度 和 滑动时间, 窗口时间类型依旧通过time characteristic 确定</span><br><span class="line">input.keyBy(x -&gt; x.f1).timeWindow(Time.seconds(10), Time.seconds(1))</span><br></pre></td></tr></table></figure>

<h6 id="会话窗口-Session-Window"><a href="#会话窗口-Session-Window" class="headerlink" title="会话窗口 Session Window"></a>会话窗口 Session Window</h6><p>会话窗口主要是将某段时间内活跃度较高的数据聚合成一个窗口计算. 触发条件是 Session Gap. 在规定的时间内没有数据接入则认为这个窗口结束,然后触发窗口计算. Session Gap 除了固定间隔的方式, 也可以动态抽取.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Session Window, 间隔为 3s</span><br><span class="line">        DataStream&lt;Tuple3&lt;String, Long, Integer&gt;&gt; aggregated = source</span><br><span class="line">                .keyBy(0)</span><br><span class="line">                .window(EventTimeSessionWindows.withGap(Time.seconds(3L)))</span><br><span class="line">                .sum(2);</span><br></pre></td></tr></table></figure>

<h6 id="全局窗口-Global-Window"><a href="#全局窗口-Global-Window" class="headerlink" title="全局窗口 Global Window"></a>全局窗口 Global Window</h6><p>全局窗口将所有key的数据分配到单个窗口中计算结果.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建 GlobalWindow</span><br><span class="line">        input.keyBy(1)</span><br><span class="line">                .window(GlobalWindows.create())</span><br><span class="line">                .sum(1);</span><br></pre></td></tr></table></figure>

<h5 id="Window-Function"><a href="#Window-Function" class="headerlink" title="Window Function"></a>Window Function</h5><p>Window Assigner 的作用是划分窗口的, 而 Window Function 就是对窗口内的数据做处理的一个过程</p>
<h6 id="ReduceFunction-增量"><a href="#ReduceFunction-增量" class="headerlink" title="ReduceFunction (增量)"></a>ReduceFunction (增量)</h6><p>对输入的两个相同类型的元素按照指定的计算方式进行聚合, 通过实现 ReduceFunction 接口就可以在reduce( ) 函数内部进行聚合操作了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input.keyBy(x -&gt; x.f1).timeWindow(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">1</span>))</span><br><span class="line">	.reduce((t1,t2) -&gt; <span class="keyword">new</span> Tuple2&lt;&gt;(t1.f0 + t2.f0, t1.f1));</span><br></pre></td></tr></table></figure>

<h6 id="AggregateFunction-增量"><a href="#AggregateFunction-增量" class="headerlink" title="AggregateFunction (增量)"></a>AggregateFunction (增量)</h6><p>AggregateFunction 相对于ReduceFunction更加灵活,但是实现起来也更复杂, AggregateFunction有 4 个需要复写的方法, 其中createAccumulator( ) 定义累加器, add( ) 定义数据的添加逻辑, getResult( ) 定义了根据 accumulator 计算结果的逻辑, merge()方法定义合并 accumulator 的逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input.keyBy(x -&gt; x.f1)</span><br><span class="line">    .timeWindow(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 自定义一个AggregateFunciton, 将相同标号 f1 的数据的 f0字符串字段合并在一起</span></span><br><span class="line">    <span class="comment">// (&quot;hello&quot;, 1L) + (&quot;world&quot;, 1L) = (&quot;hello world&quot;, 1L)</span></span><br><span class="line">    .aggregate(<span class="keyword">new</span> MyAggregateFunction());</span><br></pre></td></tr></table></figure>

<p>通过自定义的 MyAggregateFunction() 来实现 AggregateFunction 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAggregateFunction</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">String</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="comment">// 初始化累加器</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(Tuple2&lt;String, Long&gt; t, String s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 输入数据与累加器的合并</span></span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">&quot; &quot;</span> +t.f0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 得到累加器的结果</span></span><br><span class="line">            <span class="keyword">return</span> s.trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">merge</span><span class="params">(String s, String acc1)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 合并累加器</span></span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">&quot; &quot;</span> + acc1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="FoldFunction-增量"><a href="#FoldFunction-增量" class="headerlink" title="FoldFunction (增量)"></a>FoldFunction (增量)</h6><p>FoldFunction定义了如何将窗口中的输入元素与外部的元素合并的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input.keyBy(x -&gt; x.f1)</span><br><span class="line">.timeWindow(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">1</span>)).fold(<span class="string">&quot;flink&quot;</span>, (acc, t) -&gt;t.f0 + acc);</span><br></pre></td></tr></table></figure>

<p>FoldFunction在新版本已经被标记@Deprecated了, 建议使用AggregateFunction代替</p>
<h6 id="ProcessWindowFunction-全量"><a href="#ProcessWindowFunction-全量" class="headerlink" title="ProcessWindowFunction (全量)"></a>ProcessWindowFunction (全量)</h6><p>ProcessWindowFunction 相较于其他的 Window Function, 可以实现一些更复杂的计算, 比如基于整个窗口做某些指标计算 或者需要操作窗口中的状态数据和窗口元数据. Flink 提供了 ProcessWindowFunction 这个抽象类, 继承此类就可以实现ProcessWindowFunction, 其中, 必须要实现 process( ) 方法, 这是处理窗口数据的主要方法.还在一下跟窗口数据相关的方法可以有选择的实现.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessWindowFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">String</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt;, <span class="title">String</span>, <span class="title">Long</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Long s, Context context, Iterable&lt;Tuple3&lt;String, Long, Long&gt;&gt; 		elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 统计每个窗口内的所有数据的 f0字段加起来共有多少个单词</span></span><br><span class="line">        <span class="comment">// 也就做单个窗口的 wordcount</span></span><br><span class="line">        Long count = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (Tuple3&lt;String, Long, Long&gt; element : elements) &#123;</span><br><span class="line">            count += element.f0.split(<span class="string">&quot; &quot;</span>).length;</span><br><span class="line">        &#125;</span><br><span class="line">        out.collect(<span class="string">&quot;window: &quot;</span> + context.window() + <span class="string">&quot; word count: &quot;</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Window-Join"><a href="#Window-Join" class="headerlink" title="Window Join"></a>Window Join</h5><p>Flink 中支持窗口上的多流合并, 需要保证的是输入的 stream 要构建在相同的 Window 上, 并使用相同类型的 Key 作为关联条件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inputStream1.join(inputStream2)</span><br><span class="line">			<span class="comment">// 指定inputStream1的关联key</span></span><br><span class="line">			.where(<span class="number">0</span>)</span><br><span class="line">			<span class="comment">// 指定inputStream2的关联key</span></span><br><span class="line">			.equalTo(<span class="number">1</span>)</span><br><span class="line">			<span class="comment">// 指定 window Assigner</span></span><br><span class="line">			.window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">			<span class="comment">// 指定窗口计算函数</span></span><br><span class="line">			.apply(&lt;JoinFunction&gt;)</span><br></pre></td></tr></table></figure>

<h5 id="处理迟到的元素"><a href="#处理迟到的元素" class="headerlink" title="处理迟到的元素"></a>处理迟到的元素</h5><p>迟到的元素是指当这个元素来到时,这个元素所对应的窗口已经计算完毕了(也就是说水位线已经没过窗口结束时间了).这说明迟到这个特性只针对事件时间.</p>
<p>DataStream API提供了三种策略来处理迟到元素</p>
<h6 id="直接抛弃"><a href="#直接抛弃" class="headerlink" title="直接抛弃"></a>直接抛弃</h6><p>抛弃迟到的元素是event time window operator的默认行为.也就是说一个迟到的元素不会创建一个新的窗口.</p>
<p>process function可以通过比较迟到元素的时间戳和当前水位线的大小来很轻易的过滤掉迟到元素.</p>
<h6 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h6><p>迟到的元素也可以使用侧输出(side output)特性被重定向到另外的一条流中去.迟到元素所组成的侧输出流可以继续处理或者sink到持久化设施中去.</p>
<h6 id="更新窗口计算结果"><a href="#更新窗口计算结果" class="headerlink" title="更新窗口计算结果"></a>更新窗口计算结果</h6><p>由于存在迟到的元素,所以已经计算出的窗口结果是不准确和不完全的.我们可以使用迟到元素更新已经计算完的窗口结果.</p>
<p>window operator API提供了方法来明确声明我们要等待迟到元素.当使用event-time window,我们可以指定一个时间段叫做<code>allowed lateness</code>.window operator如果设置了<code>allowed lateness</code>,这个window operator在水位线没过窗口结束时间时也将不会删除窗口和窗口中的状态.窗口会在一段时间内(allowed lateness设置的)保留所有的元素.</p>
<p>当迟到元素在<code>allowed lateness</code>时间内到达时,这个迟到元素会被实时处理并发送到触发器(trigger).当水位线没过了窗口结束时间+allowed lateness时间时,窗口会被删除,并且所有后来的迟到的元素都会被丢弃.</p>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>官方文档有详细描述,这里不多赘述.</p>
<p><a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/dev/stream/state/state.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/zh/dev/stream/state/state.html</a></p>
<h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><p>Flink本身是批流统一的处理框架,所以Table API和SQL,就是批流统一的上层处理API.目前还在完善中,所以后面待完善.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compileOnly <span class="string">&quot;org.apache.flink:flink-table-api-java-bridge_$&#123;scalaBinaryVersion&#125;:$&#123;flinkVersion&#125;&quot;</span></span><br><span class="line"><span class="comment">// 本地运行，线上lib已经包含，不需要引入</span></span><br><span class="line">compileOnly <span class="string">&quot;org.apache.flink:flink-table-planner-blink_$&#123;scalaBinaryVersion&#125;:$&#123;flinkVersion&#125;&quot;</span></span><br><span class="line"><span class="comment">// 自定义函数，线上lib已经包含，不需要引入</span></span><br><span class="line">compileOnly <span class="string">&quot;org.apache.flink:flink-table-common:$&#123;flinkVersion&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>未完待续…..</strong></p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/">apache flink</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/flink">github flink</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhisheng17/flink-learning">github flink-learning</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CheckChe0803/flink-simple-tutorial">github flink-simple-tutorial</a></p>
<p><a target="_blank" rel="noopener" href="https://confucianzuoyuan.github.io/flink-tutorial/">尚硅谷</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci=''
        data-cs=''
        data-r='suda'
        data-o='xixi-cmd'
        data-a='xixi-cmd'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#QuickStart"><span class="toc-number">1.</span> <span class="toc-text">QuickStart</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.</span> <span class="toc-text">搭建执行环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">创建应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataStream-API"><span class="toc-number">2.</span> <span class="toc-text">DataStream API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DataSource"><span class="toc-number">2.1.</span> <span class="toc-text">DataSource</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">内置数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Elements"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Elements</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#File"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">File</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Socket"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">Socket</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">外部数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">第三方数据源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">自定义数据源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transformation"><span class="toc-number">2.2.</span> <span class="toc-text">Transformation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本转换算子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#filter"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#map"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#flatMap"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">flatMap</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#richFunction"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">richFunction</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%AE%E6%8E%A7%E6%B5%81%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">键控流转换算子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#keyBy"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">keyBy</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fold"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">fold</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#aggregate"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">aggregate</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#window"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">window</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#window-join"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">window join</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#split"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">split</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#select"><span class="toc-number">2.2.2.7.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#project"><span class="toc-number">2.2.2.8.</span> <span class="toc-text">project</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reduce"><span class="toc-number">2.2.2.9.</span> <span class="toc-text">reduce</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%B5%81%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="toc-number">2.2.3.</span> <span class="toc-text">多流转换算子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#union"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">union</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#connect-comap-coflatmap"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">connect,comap,coflatmap</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="toc-number">2.2.4.</span> <span class="toc-text">分布式转换算子</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#random"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">random</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#round-robin"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">round-robin</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rescale"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">rescale</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#broadcast"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">broadcast</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#global"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">global</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#custom"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">custom</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sink"><span class="toc-number">2.3.</span> <span class="toc-text">Sink</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9sink"><span class="toc-number">2.3.1.</span> <span class="toc-text">第三方sink</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#kafka"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">kafka</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#redis"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">redis</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#elasticsearch"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">elasticsearch</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89sink"><span class="toc-number">2.3.2.</span> <span class="toc-text">自定义sink</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Window"><span class="toc-number">2.4.</span> <span class="toc-text">Window</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4-time"><span class="toc-number">2.4.1.</span> <span class="toc-text">时间 time</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E4%BD%8D%E7%BA%BF-watermark"><span class="toc-number">2.4.2.</span> <span class="toc-text">水位线 watermark</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B0%B4%E5%8D%B0"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">使用水印</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#event%E6%97%B6%E9%97%B4%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">event时间的获取</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A9%BA%E9%97%B2%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">处理空闲数据源</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%AE%80%E4%BB%8B-window"><span class="toc-number">2.4.3.</span> <span class="toc-text">窗口简介 window</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Window-Assigner"><span class="toc-number">2.4.4.</span> <span class="toc-text">Window Assigner</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3-Tumbling-Windows"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">滚动窗口 Tumbling Windows</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-Sliding-Window"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">滑动窗口 Sliding Window</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%AA%97%E5%8F%A3-Session-Window"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">会话窗口 Session Window</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%AA%97%E5%8F%A3-Global-Window"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">全局窗口 Global Window</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Window-Function"><span class="toc-number">2.4.5.</span> <span class="toc-text">Window Function</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ReduceFunction-%E5%A2%9E%E9%87%8F"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">ReduceFunction (增量)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#AggregateFunction-%E5%A2%9E%E9%87%8F"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">AggregateFunction (增量)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#FoldFunction-%E5%A2%9E%E9%87%8F"><span class="toc-number">2.4.5.3.</span> <span class="toc-text">FoldFunction (增量)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ProcessWindowFunction-%E5%85%A8%E9%87%8F"><span class="toc-number">2.4.5.4.</span> <span class="toc-text">ProcessWindowFunction (全量)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Window-Join"><span class="toc-number">2.4.6.</span> <span class="toc-text">Window Join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%9F%E5%88%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.7.</span> <span class="toc-text">处理迟到的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8A%9B%E5%BC%83"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">直接抛弃</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%AA%97%E5%8F%A3%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">更新窗口计算结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#State"><span class="toc-number">2.5.</span> <span class="toc-text">State</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Table"><span class="toc-number">2.6.</span> <span class="toc-text">Table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">相关链接</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
