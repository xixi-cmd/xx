
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>docker - WeiKe</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="weike,"> 
    <meta name="description" content="私のすべてを支配してください,Docker是一个开源的容器引擎，它可以帮助我们更快地交付应用。Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用Docker，可更快地打包、测试以及部署应用程序，,"> 
    <meta name="author" content="WeiKe_Joe"> 
    <link rel="alternative" href="atom.xml" title="WeiKe" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">WeiKe</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://cn.weikecc.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">docker</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">docker</h1>
        <div class="stuff">
            <span>五月 22, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>


        </div>
        <div class="content markdown">
            <p>Docker是一个开源的<strong>容器引擎</strong>，它可以帮助我们更快地交付应用。Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用Docker，可更快地打包、测试以及部署应用程序，并可<strong>减少从编写到部署运行代码的周期</strong>。</p>
<span id="more"></span>

<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>官网有详细的安装教程，然后配置下加速器即可，我这边使用<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-qingdao/instances/mirrors">阿里云的<code>docker</code>镜像加速器</a>。</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询镜像</span></span><br><span class="line">docker search nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出镜像</span></span><br><span class="line">docker images</span><br><span class="line">docker images java</span><br><span class="line">docker images java:8</span><br><span class="line">docker images --digests</span><br><span class="line">docker images --filter &quot;dangling=true&quot;   # 展示虚悬镜像</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地镜像</span></span><br><span class="line">docker rmi hello-world</span><br><span class="line">docker rmi -f $(docker images)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存镜像</span></span><br><span class="line">docker save busybox &gt; busybox.tar</span><br><span class="line">docker save --output busybox.tar busybox</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载镜像</span></span><br><span class="line">docker load &lt; busybox.tar.gz</span><br><span class="line">docker load --input fedora.tar</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><h5 id="新建并启动容器-重要"><a href="#新建并启动容器-重要" class="headerlink" title="新建并启动容器[重要]"></a>新建并启动容器[重要]</h5><p>使用以下<code>docker run</code> 命令即可新建并启动一个容器。该命令是我们最常用的命令了，它有很多选项，下面笔者列举一些常用的选项。</p>
<p>① -d选项：表示后台运行</p>
<p>② -P选项：随机端口映射</p>
<p>③ -p选项：指定端口映射，有以下四种格式。</p>
<p><code>ip:hostPort:containerPort</code></p>
<p><code>ip::containerPort</code></p>
<p><code>hostPort:containerPort</code></p>
<p><code>containerPort</code></p>
<p>④ –network选项：指定网络模式，该选项有以下可选参数：</p>
<p><code>–network=bridge</code>： 默认选项，表示连接到默认的网桥。</p>
<p><code>–network=host</code>：容器使用宿主机的网络。</p>
<p><code>–network=container:NAME_or_ID</code>：告诉Docker让新建的容器使用已有容器的网络配置。</p>
<p><code>–network=none</code>：不配置该容器的网络，用户可自定义网络配置。</p>
<p>示例1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run java /bin/echo &#x27;Hello World&#x27;</span><br></pre></td></tr></table></figure>

<p>这样终端会打印<code>Hello World</code>的字样，跟在本地直接执行<code>/bin/echo &#39;Hello World&#39;</code> 一样。</p>
<p>示例2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 91:80 nginx</span><br></pre></td></tr></table></figure>

<p>这样就能启动一个<code>Nginx</code>容器。在本例中，我们为<code>docker run</code>添加了两个参数，含义如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d                           # 后台运行-p 宿主机端口:容器端口         # 开放容器端口到宿主机端口</span><br></pre></td></tr></table></figure>

<p>访问<a target="_blank" rel="noopener" href="http://docker宿主机ip:91/">http://Docker宿主机IP:91/</a> </p>
<p><strong>TIPS</strong></p>
<p>需要注意的是，使用docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个Docker容器。</p>
<h5 id="列出容器-重要"><a href="#列出容器-重要" class="headerlink" title="列出容器[重要]"></a>列出容器[重要]</h5><p>使用<code>docker ps</code> 命令即可列出运行中的容器。执行该命令后，可看到类似于如下的表格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES784fd3b294d7        nginx               &quot;nginx -g &#x27;daemon off&quot;   20 minutes ago      Up 2 seconds        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes</span><br></pre></td></tr></table></figure>

<p>如需列出所有容器（包括已停止的容器），可使用-a参数。</p>
<p>该表格包含了七列，含义如下：</p>
<p>① CONTAINER_ID：表示容器ID。</p>
<p>② IMAGE：表示镜像名称。</p>
<p>③ COMMAND：表示启动容器时运行的命令。</p>
<p>④ CREATED：表示容器的创建时间。</p>
<p>⑤ STATUS：表示容器运行的状态。Up表示运行中，Exited表示已停止。</p>
<p>⑥ PORTS：表示容器对外的端口号。</p>
<p>⑦ NAMES：表示容器名称。该名称默认由Docker自动生成，也可使用docker run命令的–name选项自行指定。</p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--all, -a</code></td>
<td align="left"><code>false</code></td>
<td align="left">列出所有容器，包括未运行的容器，默认只展示运行的容器</td>
</tr>
<tr>
<td align="left"><code>--filter, -f</code></td>
<td align="left"></td>
<td align="left">根据条件过滤显示内容</td>
</tr>
<tr>
<td align="left"><code>--format</code></td>
<td align="left"></td>
<td align="left">通过Go语言模板文件展示镜像</td>
</tr>
<tr>
<td align="left"><code>--last, -n</code></td>
<td align="left"><code>-1</code></td>
<td align="left">显示最近创建n个容器（包含所有状态）</td>
</tr>
<tr>
<td align="left"><code>--latest, -l</code></td>
<td align="left"><code>false</code></td>
<td align="left">显示最近创建的容器（包含所有状态）</td>
</tr>
<tr>
<td align="left"><code>--no-trunc</code></td>
<td align="left"><code>false</code></td>
<td align="left">不截断输出</td>
</tr>
<tr>
<td align="left"><code>--quiet, -q</code></td>
<td align="left"><code>false</code></td>
<td align="left">静默模式，只展示容器的编号</td>
</tr>
<tr>
<td align="left"><code>--size, -s</code></td>
<td align="left"><code>false</code></td>
<td align="left">显示总文件大小</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -n 5docker ps -a -q</span><br></pre></td></tr></table></figure>

<h5 id="停止容器-重要"><a href="#停止容器-重要" class="headerlink" title="停止容器[重要]"></a>停止容器[重要]</h5><p>使用<code>docker stop</code> 命令，即可停止容器。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--time, -t</code></td>
<td align="left"><code>10</code></td>
<td align="left">强制杀死容器前等待的时间，单位是秒</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 784fd3b294d7</span><br></pre></td></tr></table></figure>

<p>其中<code>784fd3b294d7</code> 是容器ID，当然也可使用<code>docker stop 容器名称</code> 来停止指定容器。</p>
<h5 id="强制停止容器-重要"><a href="#强制停止容器-重要" class="headerlink" title="强制停止容器[重要]"></a>强制停止容器[重要]</h5><p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--signal, -s</code></td>
<td align="left"><code>KILL</code></td>
<td align="left">向容器发送一个信号</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 784fd3b294d7</span><br></pre></td></tr></table></figure>

<h5 id="启动已停止的容器-重要"><a href="#启动已停止的容器-重要" class="headerlink" title="启动已停止的容器[重要]"></a>启动已停止的容器[重要]</h5><p>使用<code>docker run</code> 命令，即可新建并启动一个容器。对于已停止的容器，可使用<code>docker start</code> 命令来启动。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--attach, -a</code></td>
<td align="left"><code>false</code></td>
<td align="left">连接<code>STDOUT/STDERR</code>并转发信号</td>
</tr>
<tr>
<td align="left"><code>--checkpoint</code></td>
<td align="left"></td>
<td align="left">从该检查点还原</td>
</tr>
<tr>
<td align="left"><code>--checkpoint-dir</code></td>
<td align="left"></td>
<td align="left">使用自定义的检查点存储目录</td>
</tr>
<tr>
<td align="left"><code>--detach-keys</code></td>
<td align="left"></td>
<td align="left">覆盖断开容器的关键顺序</td>
</tr>
<tr>
<td align="left"><code>--interactive, -i</code></td>
<td align="left"><code>false</code></td>
<td align="left">连接容器的<code>STDIN</code></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 784fd3b294d7</span><br></pre></td></tr></table></figure>

<h5 id="重启容器-重要"><a href="#重启容器-重要" class="headerlink" title="重启容器[重要]"></a>重启容器[重要]</h5><p>可使用<code>docker restart</code> 命令来重启容器。该命令实际上是先执行了<code>docker stop</code> 命令，然后执行了<code>docker start</code> 命令。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--time, -t</code></td>
<td align="left"><code>10</code></td>
<td align="left">关闭容器前等待的时间，单位是秒</td>
</tr>
</tbody></table>
<h5 id="进入容器-重要"><a href="#进入容器-重要" class="headerlink" title="进入容器[重要]"></a>进入容器[重要]</h5><p>某场景下，我们可能需要进入运行中的容器。</p>
<p>① 使用<code>docker attach</code> 命令进入容器。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 784fd3b294d7</span><br></pre></td></tr></table></figure>

<p>很多场景下，使用<code>docker attach</code> 命令并不方便。当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。同理，如果某个窗口发生阻塞，其他窗口也无法执行操作。</p>
<p>② 使用<code>nsenter</code> 进入容器</p>
<p><code>nsenter</code>工具包含在<code>util-linux 2.23</code>或更高版本中。为了连接到容器，我们需要找到容器第一个进程的<code>PID</code>，可通过以下命令获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; $CONTAINER_ID</span><br></pre></td></tr></table></figure>

<p>获得<code>PID</code>后，就可使用<code>nsenter</code>命令进入容器了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --target &quot;$PID&quot; --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure>

<p>下面给出一个完整的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES784fd3b294d7        nginx               &quot;nginx -g &#x27;daemon off&quot;   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes[root@localhost ~]# docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; 784fd3b294d795492[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pidroot@784fd3b294d7:/#</span><br></pre></td></tr></table></figure>

<p>读者也可将以上两条命令封装成一个Shell，从而简化进入容器的过程。</p>
<p>③ docker exec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>

<h5 id="删除容器-重要"><a href="#删除容器-重要" class="headerlink" title="删除容器[重要]"></a>删除容器[重要]</h5><p>使用<code>docker rm</code> 命令即可删除指定容器。</p>
<p>命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--force, -f</code></td>
<td align="left"><code>false</code></td>
<td align="left">通过<code>SIGKILL</code>信号强制删除正在运行中的容器</td>
</tr>
<tr>
<td align="left"><code>--link, -l</code></td>
<td align="left"><code>false</code></td>
<td align="left">删除容器间的网络连接</td>
</tr>
<tr>
<td align="left"><code>--volumes, -v</code></td>
<td align="left"><code>false</code></td>
<td align="left">删除与容器关联的卷</td>
</tr>
</tbody></table>
<p>例1：删除指定容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 784fd3b294d7</span><br></pre></td></tr></table></figure>

<p>该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数。</p>
<p>例2：删除所有的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure>

<h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><p>将容器导出成一个压缩包文件。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--output, -o</code></td>
<td align="left"></td>
<td align="left">将内容写到文件而非<code>STDOUT</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export red_panda &gt; latest.tardocker export --output=&quot;latest.tar&quot; red_panda</span><br></pre></td></tr></table></figure>

<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th align="left">Name, shorthand</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--change, -c</code></td>
<td align="left"></td>
<td align="left">将<code>Dockerfile</code>指令应用到创建的镜像</td>
</tr>
<tr>
<td align="left"><code>--message, -m</code></td>
<td align="left"></td>
<td align="left">为导入的镜像设置提交信息</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import nginx2.tar nginx</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><h5 id="ADD-复制文件"><a href="#ADD-复制文件" class="headerlink" title="ADD 复制文件"></a>ADD 复制文件</h5><p>ADD复制文件</p>
<p>格式为：</p>
<ul>
<li><code>ADD &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li>
</ul>
<p>从<code>src</code>目录复制文件到容器的<code>dest</code>。其中<code>src</code>可以是<code>Dockerfile</code>所在目录的相对路径，也可以是一个URL，还可以是一个压缩包。</p>
<p>除了要复制解压文件，一般不建议使用，使用<code>RUN</code>跟<code>COPY</code>命令就可以很好替代。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jar</span></span><br></pre></td></tr></table></figure>

<h5 id="ARG-设置构建参数"><a href="#ARG-设置构建参数" class="headerlink" title="ARG 设置构建参数"></a>ARG 设置构建参数</h5><p>设置构建参数，类似于<code>ENV</code>。和<code>ENV</code>不同的是，<code>ARG</code>设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。</p>
<p>格式为：</p>
<ul>
<li><code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> user1=someuser</span><br></pre></td></tr></table></figure>

<h5 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h5><p>用于为执行容器提供默认值。每个<code>Dockerfile</code>只有一个<code>CMD</code>命令，如果指定了多个<code>CMD</code>命令，那么只有最后一条会被执行，如果启动容器的时候指定了运行的命令，则会覆盖掉<code>CMD</code>指定的命令。</p>
<p>支持三种格式：</p>
<p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (推荐使用，会解析成json数组，所以要记得要用<strong>双引号</strong>)</p>
<p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (为<code>ENTRYPOINT</code>指令提供预设参数)</p>
<p><code>CMD command param1 param2</code> (在shell中执行)</p>
<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;This is a test.&quot;</span> | wc -</span></span><br></pre></td></tr></table></figure>

<h5 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h5><p>复制文件，格式为：</p>
<ul>
<li><code>COPY &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code></li>
</ul>
<p>复制本地端的<code>src</code>到容器的<code>dest</code>。<code>COPY</code>指令和<code>ADD</code>指令类似，<code>COPY</code>不支持URL和压缩包。</p>
<h5 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h5><p>格式为：</p>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>
<li><code>ENTRYPOINT command param1 param2</code></li>
</ul>
<p><code>ENTRYPOINT</code>和<code>CMD</code>指令的目的一样，都是指定<code>Docker</code>容器启动时执行的命令，可多次设置，但只有最后一个有效。<code>ENTRYPOINT</code>不可被重写覆盖。</p>
<p><code>ENTRYPOINT</code>、<code>CMD</code>区别：<a target="_blank" rel="noopener" href="http://blog.csdn.net/newjueqi/article/details/51355510">http://blog.csdn.net/newjueqi/article/details/51355510</a></p>
<h5 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h5><p>用于设置环境变量，格式为：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key&gt;=&lt;value&gt; ...</code></li>
</ul>
<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> JAVA_HOME /path/to/java</span><br></pre></td></tr></table></figure>

<h5 id="EXPOSE-声明暴露的端口"><a href="#EXPOSE-声明暴露的端口" class="headerlink" title="EXPOSE 声明暴露的端口"></a>EXPOSE 声明暴露的端口</h5><p>用于声明在运行时容器提供服务的端口，格式为：</p>
<ul>
<li><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></li>
</ul>
<p>需要注意的是，这只是一个声明，运行时并不会因为该声明就打开相应端口。该指令的作用主要是帮助镜像使用者理解该镜像服务的守护端口；其次是当运行时使用随机映射时，会自动映射<code>EXPOSE</code>的端口。示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明暴露一个端口示例</span></span><br><span class="line"><span class="keyword">EXPOSE</span> port1</span><br><span class="line"><span class="comment"># 相应的运行容器使用的命令</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p port1 image</span></span><br><span class="line"><span class="comment"># 也可使用-P选项启动</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -P image</span></span><br><span class="line"><span class="comment"># 声明暴露多个端口示例</span></span><br><span class="line"><span class="keyword">EXPOSE</span> port1 port2 port3</span><br><span class="line"><span class="comment"># 相应的运行容器使用的命令</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p port1 -p port2 -p port3 image</span></span><br><span class="line"><span class="comment"># 也可指定需要映射到宿主机器上的端口号  </span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image</span></span><br></pre></td></tr></table></figure>

<h5 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h5><p>指定基础镜像，<code>FROM</code>指令有点像<code>Java</code>里面的<code>extend</code>关键字。需要注意的是，<code>FROM</code>指令必须指定且需要写在其他指令之前。<code>FROM</code>指令后的所有指令都依赖于该指令所指定的镜像。</p>
<p>支持三种格式：</p>
<ul>
<li><code>FROM &lt;image&gt;</code></li>
<li><code>FROM &lt;image&gt;:&lt;tag&gt;</code></li>
<li><code>FROM &lt;image&gt;@&lt;digest&gt;</code></li>
</ul>
<h5 id="LABEL-为镜像添加元数据"><a href="#LABEL-为镜像添加元数据" class="headerlink" title="LABEL 为镜像添加元数据"></a>LABEL 为镜像添加元数据</h5><p>为镜像添加元数据。</p>
<p>格式为：</p>
<ul>
<li><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li>
</ul>
<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.label-with-value=<span class="string">&quot;foo&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;This text illustrates \that label-values can span multiple lines.&quot;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="MAINTAINER-指定维护者的信息（已过时）"><a href="#MAINTAINER-指定维护者的信息（已过时）" class="headerlink" title="MAINTAINER 指定维护者的信息（已过时）"></a>MAINTAINER 指定维护者的信息（已过时）</h5><p>MAINTAINER指令用于指定维护者的信息，用于为<code>Dockerfile</code>署名。</p>
<p>格式为：</p>
<ul>
<li><code>MAINTAINER &lt;name&gt;</code></li>
</ul>
<p>示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> 周立&lt;eacdy0000@<span class="number">126</span>.com&gt;</span><br></pre></td></tr></table></figure>

<p>注：该指令已过时，建议使用如下形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">&quot;SvenDowideit@home.org.au&quot;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h5><p>该指令支持两种格式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code></li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>
</ul>
<p><code>RUN &lt;command&gt;</code> 在<code>shell</code>终端中运行，在<code>Linux</code>中默认是<code>/bin/sh -c</code> ，在<code>Windows</code>中是 <code>cmd /s /c</code>，使用这种格式，就像直接在命令行中输入命令一样。<br><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 使用exec执行，这种方式类似于函数调用。指定其他终端可以通过该方式操作，例如：<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code> ，该方式必须使用双引号[“]而不能使用单引号[‘]，因为该方式会被转换成一个<code>JSON</code> 数组。</p>
<h5 id="USER-设置用户"><a href="#USER-设置用户" class="headerlink" title="USER 设置用户"></a>USER 设置用户</h5><p>该指令用于设置启动镜像时的用户或者<code>UID</code>，写在该指令后的<code>RUN</code>、<code>CMD</code>以及<code>ENTRYPOINT</code>指令都将使用该用户执行命令。</p>
<p>格式为：</p>
<ul>
<li><code>USER 用户名</code></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure>

<h5 id="VOLUME-指定挂载点"><a href="#VOLUME-指定挂载点" class="headerlink" title="VOLUME 指定挂载点"></a>VOLUME 指定挂载点</h5><p>该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器。当容器中的应用有持久化数据的需求时可以在<code>Dockerfile</code>中使用该指令。格式为：</p>
<ul>
<li><code>VOLUME [&quot;/data&quot;]</code></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM nginxVOLUME /tmp</span><br></pre></td></tr></table></figure>

<p>当该<code>Dockerfile</code>被构建成镜像后，<code>/tmp</code>目录中的数据即使容器关闭也依然存在。如果另一个容器也有持久化的需求，并且想使用以上容器<code>/tmp</code>目录中的内容，则可使用如下命令启动容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -volume-from 容器ID 镜像名称  # 容器ID是di一个容器的ID，镜像是第二个容器所使用的镜像。</span><br></pre></td></tr></table></figure>

<h5 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h5><p>格式为：</p>
<ul>
<li><code>WORKDIR /path/to/workdir</code></li>
</ul>
<p>切换目录指令，类似于<code>cd</code>命令，写在该指令后的<code>RUN</code>，<code>CMD</code>以及<code>ENTRYPOINT</code>指令都将该目录作为当前目录，并执行相应的命令。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><code>Dockerfile</code>还有一些其他的指令，例如<code>STOPSINGAL</code>、<code>HEALTHCHECK</code>、<code>SHELL</code>等。由于并不是很常用，本书不作赘述。有兴趣的读者可前往<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a> 扩展阅读。</p>
<p><strong>CMD/ENTRYPOINT/RUN区别</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000000417103">https://segmentfault.com/q/1010000000417103</a></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a target="_blank" rel="noopener" href="https://www.docker.com/">Docker官方网站</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/docker">Docker GitHub</a></p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice">Docker 入门到实践</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci=''
        data-cs=''
        data-r='suda'
        data-o='xixi-cmd'
        data-a='xixi-cmd'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">新建并启动容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">列出容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">停止容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">强制停止容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.5.</span> <span class="toc-text">启动已停止的容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.6.</span> <span class="toc-text">重启容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.7.</span> <span class="toc-text">进入容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.8.</span> <span class="toc-text">删除容器[重要]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.9.</span> <span class="toc-text">导出容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.10.</span> <span class="toc-text">导入容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-number">3.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">基本指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ADD-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">ADD 复制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ARG-%E8%AE%BE%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">ARG 设置构建参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.3.</span> <span class="toc-text">CMD 容器启动命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COPY-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">COPY 复制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENTRYPOINT-%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-number">3.1.5.</span> <span class="toc-text">ENTRYPOINT 入口点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENV-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.6.</span> <span class="toc-text">ENV 设置环境变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXPOSE-%E5%A3%B0%E6%98%8E%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.1.7.</span> <span class="toc-text">EXPOSE 声明暴露的端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FROM-%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.8.</span> <span class="toc-text">FROM 指定基础镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LABEL-%E4%B8%BA%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.9.</span> <span class="toc-text">LABEL 为镜像添加元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MAINTAINER-%E6%8C%87%E5%AE%9A%E7%BB%B4%E6%8A%A4%E8%80%85%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%88%E5%B7%B2%E8%BF%87%E6%97%B6%EF%BC%89"><span class="toc-number">3.1.10.</span> <span class="toc-text">MAINTAINER 指定维护者的信息（已过时）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RUN-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.11.</span> <span class="toc-text">RUN 执行命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USER-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7"><span class="toc-number">3.1.12.</span> <span class="toc-text">USER 设置用户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VOLUME-%E6%8C%87%E5%AE%9A%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="toc-number">3.1.13.</span> <span class="toc-text">VOLUME 指定挂载点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-number">3.1.14.</span> <span class="toc-text">WORKDIR 指定工作目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.1.15.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">3.2.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">相关链接</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
